<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>03-C/C++软件逆向技术 | icon'Blog</title><meta name="author" content="icon"><meta name="copyright" content="icon"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="C&#x2F;C++软件逆向技术分析定位目标功能：(第一天)设置一下Debug：如下   设置一下Release：如下   对如下代码生成不同版本的exe: 123456#include &lt;stdio.h&gt;int main() &#123;	printf(&quot;hello Re&quot;);	return 0;&#125;  将debug版本的直接脱入ida：   拖入成功后。">
<meta property="og:type" content="article">
<meta property="og:title" content="03-C&#x2F;C++软件逆向技术">
<meta property="og:url" content="https://iconabc.github.io/posts/cc605c90.html">
<meta property="og:site_name" content="icon&#39;Blog">
<meta property="og:description" content="C&#x2F;C++软件逆向技术分析定位目标功能：(第一天)设置一下Debug：如下   设置一下Release：如下   对如下代码生成不同版本的exe: 123456#include &lt;stdio.h&gt;int main() &#123;	printf(&quot;hello Re&quot;);	return 0;&#125;  将debug版本的直接脱入ida：   拖入成功后。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://iconabc.github.io/img/mbc.jpg">
<meta property="article:published_time" content="2025-01-11T13:52:21.000Z">
<meta property="article:modified_time" content="2025-01-11T17:23:41.387Z">
<meta property="article:author" content="icon">
<meta property="article:tag" content="武器化开发学习">
<meta property="article:tag" content="免杀">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://iconabc.github.io/img/mbc.jpg"><link rel="shortcut icon" href="/img/shasha.png"><link rel="canonical" href="https://iconabc.github.io/posts/cc605c90.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: icon","link":"链接: ","source":"来源: icon'Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '03-C/C++软件逆向技术',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/mbc.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">22</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">22</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> about</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/shuai.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">icon'Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">03-C/C++软件逆向技术</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> about</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">03-C/C++软件逆向技术</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-01-11T13:52:21.000Z" title="发表于 2025-01-11 21:52:21">2025-01-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-01-11T17:23:41.387Z" title="更新于 2025-01-12 01:23:41">2025-01-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C-C-%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E6%8A%80%E6%9C%AF/">C/C++软件逆向技术</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">13.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>53分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="C-C-软件逆向技术"><a href="#C-C-软件逆向技术" class="headerlink" title="C&#x2F;C++软件逆向技术"></a>C&#x2F;C++软件逆向技术</h1><h2 id="分析定位目标功能：-第一天"><a href="#分析定位目标功能：-第一天" class="headerlink" title="分析定位目标功能：(第一天)"></a>分析定位目标功能：(第一天)</h2><p>设置一下Debug：如下</p>
<img src="/posts/cc605c90/image-20241228141831808.png" class="" title="image-20241228141831808">

<p>设置一下Release：如下</p>
<img src="/posts/cc605c90/image-20241228141932693.png" class="" title="image-20241228141932693">

<p>对如下代码生成不同版本的exe:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;hello Re&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将debug版本的直接脱入ida：</p>
<img src="/posts/cc605c90/image-20241228160642858.png" class="" title="image-20241228160642858">

<p>拖入成功后。</p>
<p>它会给你三种选项，如下：</p>
<img src="/posts/cc605c90/image-20241228161437585.png" class="" title="image-20241228161437585">

<p>让你选择以某一种方式对他进行解析：</p>
<p>第一种方式：pe文件的方式对你的文件进行解析</p>
<p>第二种方式：是利用dos的形式对它进行解析</p>
<p>第三种方式：是利用二进制文本的方式对它进行解析，想怎么解就怎么解</p>
<p>这里我们已经知道是pe的可以直接选择第一种。</p>
<p>下面这个是可以简单选择一些架构的：我们选择metapoc</p>
<img src="/posts/cc605c90/image-20241228161823929.png" class="" title="image-20241228161823929">

<p>加载完毕后来到这个：这个页面：</p>
<img src="/posts/cc605c90/image-20241228162701775.png" class="" title="image-20241228162701775">

<p>我们可以通过如下方法来定位一手主函数main：</p>
<h3 id="第一种方式：通过字符串来找"><a href="#第一种方式：通过字符串来找" class="headerlink" title="第一种方式：通过字符串来找"></a>第一种方式：通过字符串来找</h3><img src="/posts/cc605c90/image-20241228163410444.png" class="" title="image-20241228163410444">

<p>我们直接ctrl+f进行一下搜索：</p>
<img src="/posts/cc605c90/image-20241228163618117.png" class="" title="image-20241228163618117">

<p>然后双击点进去：</p>
<img src="/posts/cc605c90/image-20241228163719641.png" class="" title="image-20241228163719641">

<p>会发现有个名字这个是ida自动给你取的。</p>
<p>然后点击这个名字以后按下<code>ctrl+x</code>它会弹出一个交叉引用：(这里我是用的本机的ida7.7才弹出的)</p>
<img src="/posts/cc605c90/image-20241228163939324.png" class="" title="image-20241228163939324">

<p>这个所谓的<code>交叉引用</code>呢？就是你的这个字符串在全局内被调用了多少次，在哪被调用的，观察上图我们可以发现上图只有被调用了一次点击以后，选择ok。</p>
<p>ida9中可以右键点击：如下选择也可弹出：</p>
<img src="/posts/cc605c90/image-20241228164138212.png" class="" title="image-20241228164138212">

<p>观察上图我们可以发现上图只有被调用了一次点击以后，选择ok。</p>
<p>ok以后就跳到如下界面了，如下界面也就是我们的main函数：</p>
<img src="/posts/cc605c90/image-20241228164437847.png" class="" title="image-20241228164437847">

<p>接下来呢我们可以按空格把他切换到文本模式，也可以再按空格切换回流程图模式，如下：</p>
<img src="/posts/cc605c90/image-20241228164532559.png" class="" title="image-20241228164532559">



<p>也可以直接按F5把他转换成伪代码的形式：如下</p>
<img src="/posts/cc605c90/image-20241228164922054.png" class="" title="image-20241228164922054">

<h3 id="第二种方式：根据一定规则来确定"><a href="#第二种方式：根据一定规则来确定" class="headerlink" title="第二种方式：根据一定规则来确定"></a>第二种方式：根据一定规则来确定</h3><p>假设我们已经知道了其对应的生成规则：然后重新生成一个demo.。</p>
<p>然后一层一层网上找，尝试了解他的main函数是如何找到的</p>
<p>我们直接右键，选择<code>交叉引用</code>，找它的上一级调用：如下：</p>
<img src="/posts/cc605c90/image-20241228170023653.png" class="" title="image-20241228170023653">

<p>有一个<code> jmp main</code>，我们跳过去:如下</p>
<img src="/posts/cc605c90/image-20241228170216772.png" class="" title="image-20241228170216772">

<p>这层是只有一个 <code>jmp _main</code>跳过去的：</p>
<p><strong>确定第1层：</strong><code>jmp _main</code></p>
<hr>

<p>接下来我们直接：右键查看上一层：如下</p>
<img src="/posts/cc605c90/image-20241228170444961.png" class="" title="image-20241228170444961">

<p>我们会发现它传入了3个参数：</p>
<img src="/posts/cc605c90/image-20241228170554453.png" class="" title="image-20241228170554453">

<p>然后我们观察会发现他是这3个<code>call</code>里面的最后一个<code>call</code></p>
<p>于是乎我们可以记录如下特征：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov     ecx, [eax]</span><br><span class="line">push    ecx             ; argc</span><br><span class="line">call    _main_0</span><br></pre></td></tr></table></figure>

<p>也可以记录<strong>进最后一个call</strong></p>
<p><strong>确定第2层：上面记录的就是第二层的特征</strong></p>
<hr>

<p>接下来我们继续进入上一层：</p>
<p>还是右键进入同上一样的操作：如下</p>
<img src="/posts/cc605c90/image-20241228171049211.png" class="" title="image-20241228171049211">

<p>我们可以将这几行作为一个特征：如下</p>
<img src="/posts/cc605c90/image-20241228171211010.png" class="" title="image-20241228171211010">

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">经过整理：如下所示即为这一层的特征</span><br><span class="line">movzx</span><br><span class="line">test</span><br><span class="line">jz</span><br><span class="line">mov</span><br><span class="line">mov</span><br><span class="line">push</span><br><span class="line">call</span><br><span class="line">add</span><br><span class="line">call</span><br></pre></td></tr></table></figure>

<p><strong>确定第3层</strong>：如上特征</p>
<hr>

<p>接下来我们继续往上找，找到这里的函数头：</p>
<img src="/posts/cc605c90/image-20241228171822419.png" class="" title="image-20241228171822419">

<p>找到其函数头然后进入上一层：如下</p>
<img src="/posts/cc605c90/image-20241228172202914.png" class="" title="image-20241228172202914">

<p>发现如下特征：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">call</span><br><span class="line">call</span><br><span class="line">然后我们可以记录一下特征是第二个call</span><br></pre></td></tr></table></figure>

<p><strong>确定第4层</strong>：特征如上</p>
<hr>

<p>接下来我们继续向上找看看还有没有上一层：</p>
<p>找到函数头，然后进入上一层：如下：</p>
<img src="/posts/cc605c90/image-20241228172439028.png" class="" title="image-20241228172439028">

<p>进入后如下</p>
<img src="/posts/cc605c90/image-20241228172513294.png" class="" title="image-20241228172513294">

<p>这一层就1个<code>call</code>:</p>
<p>直接记录就对了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call</span><br></pre></td></tr></table></figure>

<p><strong>确定第5层</strong>：如上。</p>
<hr>

<p>再继续向上一层：</p>
<img src="/posts/cc605c90/image-20241228172723292.png" class="" title="image-20241228172723292">

<p>这一层呢是一个jmp，并且jmp这一层呢已经到start了，说明已经到头了</p>
<p>特征：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp</span><br></pre></td></tr></table></figure>

<p><strong>确定第6层</strong></p>
<hr>

<p><strong>根据上述流程我们倒着把他记录了下来。</strong></p>
<p>接下来我们根据上述流程正着进这个main函数。</p>
<p>利用<strong>x64dbg</strong>来进行一下动态调试：</p>
<p>一打开我们就来到了：ntdll.dll模块下，如下：</p>
<img src="/posts/cc605c90/image-20241228185007916.png" class="" title="image-20241228185007916">

<p>直接F9跳入到我自己的程序临空：如下：</p>
<img src="/posts/cc605c90/image-20241228185158107.png" class="" title="image-20241228185158107">

<p>进入以后我就可以掏出我自己的规则：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">X86 Debug：</span><br><span class="line">1.jmp main</span><br><span class="line">2.进入最后一个call</span><br><span class="line">3.</span><br><span class="line">movzx</span><br><span class="line">test</span><br><span class="line">jz</span><br><span class="line">mov</span><br><span class="line">mov</span><br><span class="line">push</span><br><span class="line">call</span><br><span class="line">add</span><br><span class="line">call</span><br><span class="line">4.第二个call</span><br><span class="line">5.call</span><br><span class="line">6.jmp</span><br><span class="line"></span><br><span class="line">倒过来就是正向的进入main规则了</span><br></pre></td></tr></table></figure>

<p>直接F8<code> jmp</code>进入 入口点：如下：</p>
<img src="/posts/cc605c90/image-20241228185730275.png" class="" title="image-20241228185730275">

<p>进入以后这里就一个call我们直接：<strong>F8下一步到call上以后直接F7跟进这个call</strong></p>
<img src="/posts/cc605c90/image-20241228185833944.png" class="" title="image-20241228185833944">

<p>跟进以后可以看到如下内容：如下图：</p>
<img src="/posts/cc605c90/image-20241228185955728.png" class="" title="image-20241228185955728">

<p><strong>根据规则我们需要进入第二个call</strong>：F8 F8 F7跟进：如下图：</p>
<img src="/posts/cc605c90/image-20241228190213587.png" class="" title="image-20241228190213587">

<p>然后根据下一个规则：</p>
<p>找如下特征：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">3.</span><br><span class="line">movzx</span><br><span class="line">test</span><br><span class="line">jz</span><br><span class="line">mov</span><br><span class="line">mov</span><br><span class="line">push</span><br><span class="line">call</span><br><span class="line">add</span><br><span class="line">call</span><br></pre></td></tr></table></figure>

<p>找到如下特征以后：F2下个断点：如下:</p>
<img src="/posts/cc605c90/image-20241228190718677.png" class="" title="image-20241228190718677">

<p>然后F9运行到此：然后F2取消断点：如下：</p>
<img src="/posts/cc605c90/image-20241228190848258.png" class="" title="image-20241228190848258">

<p>然后继续F7跟进：如下：</p>
<img src="/posts/cc605c90/image-20241228191335207.png" class="" title="image-20241228191335207">

<p>然后继续根据规则：进入最后一个call:</p>
<p>F2下个断点然后F9运行到这，以后F2取消断点：如下：</p>
<img src="/posts/cc605c90/image-20241228191511004.png" class="" title="image-20241228191511004">

<p>F7跟进去：如下：</p>
<img src="/posts/cc605c90/image-20241228191605680.png" class="" title="image-20241228191605680">

<p>然后我们直接F8jmp：可以成功看到我们的main函数：如下：</p>
<img src="/posts/cc605c90/image-20241228191709022.png" class="" title="image-20241228191709022">

<img src="/posts/cc605c90/image-20241228191843017.png" class="" title="image-20241228191843017">

<p>上述的就是X86 Debug的一个根据结果倒过来找路线的全过程。</p>
<p>然后可以自己调试一下前面生成的<code>x64 debug</code></p>
<p>过程我忽略一下：直接找到如下规则：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">x64 debug：</span><br><span class="line"></span><br><span class="line">第一层：</span><br><span class="line">main_0          proc near               </span><br><span class="line">jmp     main</span><br><span class="line">main_0          endp</span><br><span class="line"></span><br><span class="line">第二层：</span><br><span class="line">最后一个call</span><br><span class="line"></span><br><span class="line">第三层：</span><br><span class="line">call    j___scrt_is_nonwritable_in_current_image</span><br><span class="line">movzx   eax, al</span><br><span class="line">test    eax, eax</span><br><span class="line">jz      short loc_140067DE9</span><br><span class="line">mov     rax, [rsp+68h+var_30]</span><br><span class="line">mov     rcx, [rax]      ; Callback</span><br><span class="line">call    j__register_thread_local_exe_atexit_callback</span><br><span class="line"></span><br><span class="line">call    ?invoke_main@@YAHXZ ; invoke_main(void)</span><br><span class="line">mov     [rsp+68h+Code], eax</span><br><span class="line">call    j___scrt_is_managed_app</span><br><span class="line"></span><br><span class="line">倒数第二个call</span><br><span class="line"></span><br><span class="line">第四层：</span><br><span class="line">第二个call</span><br><span class="line"></span><br><span class="line">第五层：</span><br><span class="line">只有一个call直接进</span><br><span class="line"></span><br><span class="line">第六层：</span><br><span class="line">jmp     mainCRTStartup</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">x86 release：</span><br><span class="line"></span><br><span class="line">第一层：</span><br><span class="line">push    eax             ; envp</span><br><span class="line">push    edi             ; argv</span><br><span class="line">push    dword ptr [esi] ; argc</span><br><span class="line">call    _main</span><br><span class="line"></span><br><span class="line">第二层：</span><br><span class="line">call    ___security_init_cookie</span><br><span class="line">jmp     __scrt_common_main_seh</span><br><span class="line">直接jmp</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>选择高亮模式进行调试是个看着会舒服很多：</p>
<img src="/posts/cc605c90/image-20241228200450777.png" class="" title="image-20241228200450777">

<h3 id="第三种方式：导入表查看"><a href="#第三种方式：导入表查看" class="headerlink" title="第三种方式：导入表查看"></a>第三种方式：导入表查看</h3><p>首先生成如下代码exe</p>
<p><code>Release x86</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//弹窗</span></span><br><span class="line">	<span class="built_in">MessageBoxA</span>(<span class="literal">NULL</span>,<span class="string">&quot;Msg&quot;</span>,<span class="string">&quot;rkvir&quot;</span>, MB_OK);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="静态调试查询演示："><a href="#静态调试查询演示：" class="headerlink" title="静态调试查询演示："></a>静态调试查询演示：</h4><p>拖入IDA9.0</p>
<p>首先，它已经直接识别出main函数：如下：</p>
<img src="/posts/cc605c90/image-20241228213543861.png" class="" title="image-20241228213543861">

<p><strong>如果没有识别出来呢？</strong></p>
<p>我们可以去导入表内看看：如下：用到的api都在下显示了</p>
<img src="/posts/cc605c90/image-20241228213708436.png" class="" title="image-20241228213708436">

<p>我们ctrl+F进行一下搜索：如下：</p>
<img src="/posts/cc605c90/image-20241228213835358.png" class="" title="image-20241228213835358">

<p>双击点击进入：如下：</p>
<img src="/posts/cc605c90/image-20241228214009926.png" class="" title="image-20241228214009926">

<p>我们会看到他进行了一个跨模块的引用：</p>
<p><strong><code>@16</code>是什么呢？</strong></p>
<p>就是它的参数：32位加4字节一个</p>
<p>MessageBoxA四个参数</p>
<p><strong>前面粉色的代表什么呢？</strong></p>
<p>粉色就代表着它是一个跨模块的调用，它是在其他的模块里拥有的这么一个东西</p>
<p>上方<code>int (__stdcall *MessageBoxA)</code>还说明其返回值，以及调用约定</p>
<p>接下来我们直接对其进行一个<code>右键+交叉引用</code>的形式来找他的这个位置，如下：</p>
<img src="/posts/cc605c90/image-20241228214748691.png" class="" title="image-20241228214748691">

<p>发现两个位置都在调用，其实两个位置都一样，如下：</p>
<img src="/posts/cc605c90/image-20241228214918232.png" class="" title="image-20241228214918232">

<p>会发现我们已经成功找到main函数了。</p>
<h4 id="动态调试演示："><a href="#动态调试演示：" class="headerlink" title="动态调试演示："></a>动态调试演示：</h4><p>利用x64dbg打开程序，右键——&gt;搜索——&gt;所有模块——&gt;跨模块调用如下：</p>
<img src="/posts/cc605c90/image-20241228215448207.png" class="" title="image-20241228215448207">

<img src="/posts/cc605c90/image-20241228215554752.png" class="" title="image-20241228215554752">

<p>在左下角的搜索框内搜索：MessageBoxA：如下：</p>
<img src="/posts/cc605c90/image-20241228215645332.png" class="" title="image-20241228215645332">

<p>然后双击直接进入：</p>
<img src="/posts/cc605c90/image-20241228215721599.png" class="" title="image-20241228215721599">

<h3 id="利用方法找到指定功能："><a href="#利用方法找到指定功能：" class="headerlink" title="利用方法找到指定功能："></a>利用方法找到指定功能：</h3><p>上述的这些方法也不见得非得用来找main函数，也可以用来找一些指定的功能。</p>
<p>比方说我来写这样一个程序：（选择MFC程序）</p>
<p>创建新项目：如下</p>
<img src="/posts/cc605c90/image-20241228215952185.png" class="" title="image-20241228215952185">

<p>然后直接生成这个文件点击<code>资源文件</code>选择<code>MFCApplication1.rc</code>进入如下界面：</p>
<img src="/posts/cc605c90/image-20241228234024080.png" class="" title="image-20241228234024080">

<p>并且修改成上图模样，然后右键<code>button1</code>属性</p>
<p>修改如下：</p>
<img src="/posts/cc605c90/image-20241228234308485.png" class="" title="image-20241228234308485">

<p>然后双击<code>Msg</code>：如下：</p>
<img src="/posts/cc605c90/image-20241228234503803.png" class="" title="image-20241228234503803">

<p>跳转到此处：如下：</p>
<img src="/posts/cc605c90/image-20241228234544180.png" class="" title="image-20241228234544180">

<p>并在其中写入弹窗代码：如下：</p>
<img src="/posts/cc605c90/image-20241228234725822.png" class="" title="image-20241228234725822">

<p>完成以后配置一下项目属性：设置成如下：</p>
<img src="/posts/cc605c90/image-20241228234902369.png" class="" title="image-20241228234902369">

<p>完成以后我们直接**<code>右键</code>——&gt;<code>重新生成</code>**生成一个exe文件。如下：</p>
<img src="/posts/cc605c90/image-20241228235114189.png" class="" title="image-20241228235114189">

<p>其能达到这么一个效果：如下：</p>
<img src="/posts/cc605c90/image-20241229001646272.png" class="" title="image-20241229001646272">

<h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h4><p>我们该如何找到如下功能点呢？</p>
<img src="/posts/cc605c90/image-20241229000140394.png" class="" title="image-20241229000140394">

<p>拖入ida以后：</p>
<p>我们可以看看其字符串，也可以看看其导入表。</p>
<p>这里我直接对导入表进行一个翻看然后<code>ctrl+F</code>搜索<code>MessageBoxA</code>然后找到其函数以后再对其进行<code>右键查询交叉引用</code>找到其调用然后对函数进行一个重命名：如下：</p>
<img src="/posts/cc605c90/image-20241229000422227.png" class="" title="image-20241229000422227">

<p>接下来对其再进行一个交叉引用：如下：</p>
<img src="/posts/cc605c90/image-20241229000533596.png" class="" title="image-20241229000533596">

<p>跳转过来以后我们继续对其进行交叉引用继续往上追：如下：</p>
<img src="/posts/cc605c90/image-20241229000641348.png" class="" title="image-20241229000641348">

<p>上层结果如下：</p>
<img src="/posts/cc605c90/image-20241229001042381.png" class="" title="image-20241229001042381">

<hr>

<p><strong>接下来我们给原本的这个程序加点东西来分析：</strong></p>
<img src="/posts/cc605c90/image-20241229001329439.png" class="" title="image-20241229001329439">

<p>然后给其添加变量，如下：</p>
<img src="/posts/cc605c90/image-20241229001403784.png" class="" title="image-20241229001403784">

<img src="/posts/cc605c90/image-20241229001454624.png" class="" title="image-20241229001454624">

<p>这样设置完两个变量之后我们双击就不弹窗，我们让其做一个对比比较：</p>
<p>功能：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCApplication1Dlg::OnBnClickedButton1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">UpdateData</span>(TRUE);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (m_IntA == m_IntB)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">MessageBoxA</span>(<span class="literal">NULL</span>, <span class="string">&quot;Success!&quot;</span>, <span class="string">&quot;Msg&quot;</span>, MB_OK);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">MessageBoxA</span>(<span class="literal">NULL</span>, <span class="string">&quot;Faild!&quot;</span>, <span class="string">&quot;Msg&quot;</span>, MB_OK);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UpdateData</span>(FALSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如下：</p>
<img src="/posts/cc605c90/image-20241229003553590.png" class="" title="image-20241229003553590">

<p>然后<strong>重新生成</strong>。</p>
<p>先将其拖入ida中加载，有一些慢，那我们进行一下动态调试：如下：</p>
<img src="/posts/cc605c90/image-20241229004024866.png" class="" title="image-20241229004024866">

<p>现在我们要做的就是要找出他的对比：</p>
<p>可以看到有如下效果：</p>
<img src="/posts/cc605c90/image-20241229004139732.png" class="" title="image-20241229004139732">

<img src="/posts/cc605c90/image-20241229004158469.png" class="" title="image-20241229004158469">

<p>先将其运行起来：如下：</p>
<img src="/posts/cc605c90/image-20241229004626350.png" class="" title="image-20241229004626350">

<p>那么现在呢我们就是要找出他其中的对比。</p>
<p>我们直接**<code>右键搜索</code>——&gt;<code>跨模块调用</code>**</p>
<img src="/posts/cc605c90/image-20241229004818255.png" class="" title="image-20241229004818255">

<p><strong>从这里找到他的弹窗的那个东西！</strong>！！</p>
<p>我们找他是有一定依据的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">弹窗</span><br><span class="line">MessageBoxA/W</span><br><span class="line">afxMessageBox</span><br><span class="line">CreateWindow</span><br></pre></td></tr></table></figure>

<p>我们可以追踪到他的根源，我们可以做出如下操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bp MessageBoxA 下断点（软件断点）</span><br></pre></td></tr></table></figure>

<img src="/posts/cc605c90/image-20241229005318707.png" class="" title="image-20241229005318707">

<p>然后回车，这样他就根据我们的api给我们下了一个断点。如下：</p>
<img src="/posts/cc605c90/image-20241229005428915.png" class="" title="image-20241229005428915">

<p>又或者我们可以来查看跨模块调用以后直接搜索这个函数<code>MessageBoxA</code>,如下：</p>
<img src="/posts/cc605c90/image-20241229005650418.png" class="" title="image-20241229005650418">

<p>然后双击进入，再点击如下：</p>
<img src="/posts/cc605c90/image-20241229005936043.png" class="" title="image-20241229005936043">

<p>随便点一个跟进去，无论是不是你都可以下个断点，如下：</p>
<img src="/posts/cc605c90/image-20241229010043713.png" class="" title="image-20241229010043713">

<p>不论是上面的那种方式我们都是可以找到这个位置的。</p>
<p>接下来让其运行起来我们就可以进行调试了，然后点击按钮：如下：</p>
<img src="/posts/cc605c90/image-20241229010952692.png" class="" title="image-20241229010952692">

<p>接下来我们还要找一个向上的堆栈：他停在上面的断点后，我们点击调用堆栈如下：</p>
<p>调用堆栈就你来源于哪，就是你上一级的调用和上上一级的调用都是来源于哪。</p>
<img src="/posts/cc605c90/image-20241229011354436.png" class="" title="image-20241229011354436">

<p>或者你调用堆栈都不用找，直接在<code>堆栈窗口</code>，右键选择<code>转到ESP</code>，如下：</p>
<img src="/posts/cc605c90/image-20241229134217446.png" class="" title="image-20241229134217446">

<p>这里就直接找到了：如下：</p>
<img src="/posts/cc605c90/image-20241229134928360.png" class="" title="image-20241229134928360">

<p>成功找到了返回地址。</p>
<p>既然已经找到了其返回地址，我们来分析一下这段逻辑：如下：</p>
<img src="/posts/cc605c90/image-20241229135538475.png" class="" title="image-20241229135538475">

<p>我们可以看到<code>jne mfcapplication1.6253AA</code>这条指令，来执行的跳转，如果失败他就会是一条虚线跳转到后面指定的地址<code>6253AA</code>，成功则继续执行向下的逻辑。</p>
<p>我们可以看到其上方有个<code>jne</code>的上方有个<code>cmp</code>，不出意外的情况下这个<code>cmp</code>就起到了一个关键的对比作用：于是我F2下个断点来分析：如下：</p>
<img src="/posts/cc605c90/image-20241229140208469.png" class="" title="image-20241229140208469">

<p>然后我们直接给其运行起来：如下：</p>
<img src="/posts/cc605c90/image-20241229140313678.png" class="" title="image-20241229140313678">

<p>然后我们再给其设置个值然后点击按钮看看，如下：</p>
<img src="/posts/cc605c90/image-20241229140438126.png" class="" title="image-20241229140438126">

<p>点击完毕以后其断在了这里：如下：</p>
<img src="/posts/cc605c90/image-20241229140549499.png" class="" title="image-20241229140549499">

<p>他断在这里以后我们查看其后面对应存储的值都在哪：观察如下：</p>
<p>edx：</p>
<img src="/posts/cc605c90/image-20241229140737626.png" class="" title="image-20241229140737626">

<p>然后我们右键转到内存中指定地址查看其对应所存值：如下：</p>
<img src="/posts/cc605c90/image-20241229141051273.png" class="" title="image-20241229141051273">

<p>其<code>[ecx+D8]</code>内存中对应存的值正是<code>0</code></p>
<img src="/posts/cc605c90/image-20241229141502133.png" class="" title="image-20241229141502133">

<p>然后我们点击运行：如下：0并不等于2于是其发生跳转</p>
<img src="/posts/cc605c90/image-20241229141836720.png" class="" title="image-20241229141836720">

<p>继续实验：我们重新调整值：如下</p>
<img src="/posts/cc605c90/image-20241229142035537.png" class="" title="image-20241229142035537">

<p>观察所存值的变化：如下：</p>
<img src="/posts/cc605c90/image-20241229142155305.png" class="" title="image-20241229142155305">

<p>当他们两者相同时，我F8向下走一步我们会发现**<code>ZF</code>位**就等于1了，也就说明其两者相减为0也就是说，其两者相等：如下：</p>
<img src="/posts/cc605c90/image-20241229142410629.png" class="" title="image-20241229142410629">

<p>既然两者相等再运行他自然而然的就走向成功了，如下：</p>
<img src="/posts/cc605c90/image-20241229143025723.png" class="" title="image-20241229143025723">

<h5 id="扩展："><a href="#扩展：" class="headerlink" title="扩展："></a>扩展：</h5><p>现在我们大概知道了他的运行逻辑，<strong>那么是不是可以尝试逆转一下结果呢，让本该Faild的，变成Success</strong></p>
<p>一个<code>Msg</code>停在此处：如下：</p>
<img src="/posts/cc605c90/image-20241229144044153.png" class="" title="image-20241229144044153">

<p><strong>法一</strong>：修改内存地址中的值为2：如下：</p>
<img src="/posts/cc605c90/image-20241229144341902.png" class="" title="image-20241229144341902">

<p>一直<code>F8</code>下一步发现成功逆转结果：</p>
<img src="/posts/cc605c90/image-20241229144506190.png" class="" title="image-20241229144506190">

<p><strong>法二</strong>：在发生跳转之前改变flag标志位<code>ZF</code>的值：如下：</p>
<img src="/posts/cc605c90/image-20241229145011655.png" class="" title="image-20241229145011655">

<p>双击<code>ZF</code>就改了：如下：</p>
<img src="/posts/cc605c90/image-20241229145258084.png" class="" title="image-20241229145258084">

<p>成功逆转。</p>
<p><strong>法三</strong>：直接改变跳转指令：</p>
<p>快捷键“Space”直接修改汇编指令：如下：</p>
<img src="/posts/cc605c90/image-20241229150645613.png" class="" title="image-20241229150645613">

<p>修改完成后成功逆转，如下：</p>
<img src="/posts/cc605c90/image-20241229150834352.png" class="" title="image-20241229150834352">

<img src="/posts/cc605c90/image-20241229150855181.png" class="" title="image-20241229150855181">

<p><strong>法四</strong>：直接将<code>jne</code>指令nop掉：</p>
<img src="/posts/cc605c90/image-20241229151104725.png" class="" title="image-20241229151104725">

<p>成功逆转，如下：</p>
<img src="/posts/cc605c90/image-20241229151208390.png" class="" title="image-20241229151208390">

<img src="/posts/cc605c90/image-20241229151147024.png" class="" title="image-20241229151147024">

<p>以上的四种方法也就是，我们破解的一种思路，也是我们功能定位的一种思路。</p>
<hr>

<h2 id="函数调用约定：（第二天）"><a href="#函数调用约定：（第二天）" class="headerlink" title="函数调用约定：（第二天）"></a>函数调用约定：（第二天）</h2><p>示例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;HelloWorld!\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 	<span class="built_in">test</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对其生成的exe文件拖入IDA进行调试：进入到如下位置：如下：</p>
<img src="/posts/cc605c90/image-20241229213709288.png" class="" title="image-20241229213709288">

<p>一般来说第二个call就是我们自己的函数。</p>
<p>高版本的编译器就是如下：</p>
<p>上下两个<code>call</code>：</p>
<p><strong>第一个是编译器给你加的一个安全检查,获取类似一个线程id之类，反正就是做一个安全检查</strong></p>
<p><strong>第二个同样是一个安全检查<code>Checkesp</code>,检查你的堆栈是否是安全的，是否是平衡的。</strong></p>
<p>我们来利用x64dbg来动态调试来看一看会更明确一些。如下：</p>
<img src="/posts/cc605c90/image-20241229214406685.png" class="" title="image-20241229214406685">

<img src="/posts/cc605c90/image-20241229214438572.png" class="" title="image-20241229214438572">

<img src="/posts/cc605c90/image-20241229214658915.png" class="" title="image-20241229214658915">

<img src="/posts/cc605c90/image-20241229215740305.png" class="" title="image-20241229215740305">

<img src="/posts/cc605c90/image-20241229215803106.png" class="" title="image-20241229215803106">

<p>上面是走过来的流程我们主要看下面两张图：如下：</p>
<p>第一个call:</p>
<img src="/posts/cc605c90/image-20241229215845160.png" class="" title="image-20241229215845160">

<img src="/posts/cc605c90/image-20241229215906484.png" class="" title="image-20241229215906484">

<p>第二个call:</p>
<img src="/posts/cc605c90/image-20241229215951178.png" class="" title="image-20241229215951178">

<img src="/posts/cc605c90/image-20241229220007650.png" class="" title="image-20241229220007650">

<p>其实他的安全检查也是可以删掉的在设置内进行一下调整，如下：</p>
<img src="/posts/cc605c90/image-20241229220431744.png" class="" title="image-20241229220431744">

<p>现在我将上述规则设置成默认值，然后重新生成exe来调试看看呢：如下：</p>
<img src="/posts/cc605c90/image-20241229220806560.png" class="" title="image-20241229220806560">

<p>我们会发现下面那个checkEsp不见了对吧。</p>
<p>既然如此，那么我们尝试给他的所有保护都给关了，看看程序最原始的状态是个什么样子：如下：</p>
<img src="/posts/cc605c90/image-20241229221110943.png" class="" title="image-20241229221110943">

<p>还有将SDL检查关闭：如下：</p>
<img src="/posts/cc605c90/image-20241229221332487.png" class="" title="image-20241229221332487">

<p>重新生成。</p>
<p>我们已经将能关的的都尽量关了，现在main函数长这个样子：如下：</p>
<img src="/posts/cc605c90/image-20241229221842368.png" class="" title="image-20241229221842368">

<p>进入下面这个call就是我们自己写的那个函数test：如下：</p>
<img src="/posts/cc605c90/image-20241229221941156.png" class="" title="image-20241229221941156">

<p>ida打开看看test函数：如下：</p>
<img src="/posts/cc605c90/image-20241229222509583.png" class="" title="image-20241229222509583">

<p>现在我们进入test程序来分析这个函数，这段汇编大概干了些什么：右键如下可以进行一下记录：</p>
<img src="/posts/cc605c90/image-20241229222735687.png" class="" title="image-20241229222735687">

<p>记录分析的内容如下展示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">test proc near</span><br><span class="line">push    ebp             ; 保存环境，保存原始ebp的值，因为一会会把esp的值覆盖到现有的ebp上</span><br><span class="line">mov     ebp, esp        ; 把esp给到ebp，然后后续在函数内部均使用ebp作为基准进行寻址</span><br><span class="line">sub     esp, 40h        ; 保护原有堆栈不被覆盖，抬出一块</span><br><span class="line">push    ebx             ; 保存ebx，esi，edi的值，函数的使用过程中可能会用到，防止原有的值丢失</span><br><span class="line">push    esi</span><br><span class="line">push    edi</span><br><span class="line">mov     ecx, offset unk_50F003</span><br><span class="line">call    j_@__CheckForDebuggerJustMyCode@4 ; 编译器添加的安全检查函数</span><br><span class="line">push    offset Format   ; &quot;HelloWorld!\r\n&quot;</span><br><span class="line">call    j__printf       ; 这里就是我们打印用的一个printf函数</span><br><span class="line">add     esp, 4          ; 保持堆栈平衡，平掉1个参数（4字节）就是上面的那个安全检查函数</span><br><span class="line">pop     edi</span><br><span class="line">pop     esi</span><br><span class="line">pop     ebx             ; 还原现场ebx，edi，esi的值</span><br><span class="line">mov     esp, ebp        ; 还原esp的值</span><br><span class="line">pop     ebp             ; 原有的ebp的值还原给ebp</span><br><span class="line">retn                    ; 返回函数结束</span><br><span class="line">test endp</span><br></pre></td></tr></table></figure>

<h3 id="函数调用约定："><a href="#函数调用约定：" class="headerlink" title="函数调用约定："></a>函数调用约定：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_cdecl</span><br><span class="line">_stdcall</span><br><span class="line">_fastcall</span><br></pre></td></tr></table></figure>

<h4 id="cdecl"><a href="#cdecl" class="headerlink" title="_cdecl:"></a>_cdecl:</h4><p>示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//强制转换成_cdecl</span></span><br><span class="line"><span class="function"><span class="type">int</span> _cdecl <span class="title">test</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c,<span class="type">int</span> d,<span class="type">int</span> f)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b + c + d + f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//_cdecl</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> nRes = <span class="built_in">test</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Res = %d \r\n&quot;</span>, nRes);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成exe后拖入ida进行一手分析：</p>
<p>首先我们来到main函数下，如下：</p>
<img src="/posts/cc605c90/image-20241229230648801.png" class="" title="image-20241229230648801">

<p>我们来着重关注一下这一段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">push    5               ; int</span><br><span class="line">push    4               ; int</span><br><span class="line">push    3               ; int</span><br><span class="line">push    2               ; int</span><br><span class="line">push    1               ; int</span><br><span class="line">call    _test</span><br><span class="line">add     esp, 14h    ;平栈上面各是4字节一共20字节也就是0x14个字节</span><br></pre></td></tr></table></figure>

<p>点击<code>_test</code>我们会进入一个跳转表：如下：</p>
<img src="/posts/cc605c90/image-20241229231053996.png" class="" title="image-20241229231053996">

<p>跳入我们的函数<code>test</code>：如下：</p>
<img src="/posts/cc605c90/image-20241229231210271.png" class="" title="image-20241229231210271">

<img src="/posts/cc605c90/image-20241229231311628.png" class="" title="image-20241229231311628">

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">arg_0= dword ptr  8		;这里也就是arg_0参数他在堆栈中的地址就在：[ebp + 8h]</span><br><span class="line">arg_4= dword ptr  0Ch		;[ebp + Ch]</span><br><span class="line">arg_8= dword ptr  10h		;[ebp + 10h]</span><br><span class="line">arg_C= dword ptr  14h		;[ebp + 14h]</span><br><span class="line">arg_10= dword ptr  18h		;[ebp + 18h]</span><br><span class="line"></span><br><span class="line">他存储了如下一些内容：</span><br><span class="line"></span><br><span class="line">[ebp] : ret</span><br><span class="line">[ebp + 8h]</span><br><span class="line">[ebp + Ch]</span><br><span class="line">[ebp + 10h]</span><br><span class="line">[ebp + 14h]</span><br><span class="line">[ebp + 18h]</span><br></pre></td></tr></table></figure>

<p> 然后我们利用x64dbg来进行查看我们调用这个函数时堆栈的相关变化：如下：</p>
<img src="/posts/cc605c90/image-20241229233419083.png" class="" title="image-20241229233419083">

<p>当我们跟进call以后，堆栈就会存入等会我们要返回的地址：如下：</p>
<img src="/posts/cc605c90/image-20241229233521547.png" class="" title="image-20241229233521547">

<p><code>push ebp</code>：如下：</p>
<img src="/posts/cc605c90/image-20241229233702781.png" class="" title="image-20241229233702781">

<p>进入堆栈的是如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ==&gt;    0019FE88                                        0019FEF4   ebp   </span><br><span class="line">$+4      0019FE8C                                        004503D2   返回到 funcrule._main+22 自 funcrule.__enc$textbss$end+2373</span><br><span class="line">$+8      0019FE90                                        00000001   </span><br><span class="line">$+C      0019FE94                                        00000002   </span><br><span class="line">$+10     0019FE98                                        00000003   </span><br><span class="line">$+14     0019FE9C                                        00000004   </span><br><span class="line">$+18     0019FEA0                                        00000005   </span><br></pre></td></tr></table></figure>

<p><code>mov ebp,esp</code>：如下效果：</p>
<img src="/posts/cc605c90/image-20241229234103024.png" class="" title="image-20241229234103024">

<p><code>sub esp,40</code>：进行抬栈操作：<strong>这40h个字节能够保证我们在函数堆栈内出现问题不会淹没到原有的堆栈</strong>，如下：</p>
<img src="/posts/cc605c90/image-20241229234504508.png" class="" title="image-20241229234504508">

<p>这中间就相当于是一层缓冲层：</p>
<p><strong>底下呢就是我们的老的堆栈，上方呢就是我们为我们的内部函数的堆栈，中间呢是缓冲层防止我们内部函数的堆栈溢出淹没到我们原来的堆栈。</strong></p>
<p> 后面的指令就是进行加法以后存储到eax中：如下</p>
<img src="/posts/cc605c90/image-20241230000144148.png" class="" width="">

<p>进栈多少就出栈多少，一一pop出，如下：</p>
<img src="/posts/cc605c90/image-20241230113611834.png" class="" title="image-20241230113611834">

<p><code>mov esp,ebp</code>：<strong>指令将ebp赋值给esp就相当于将前面抬栈的部分全部抹掉了</strong>，所以此处不需要平栈他也能正常的回来。如下：</p>
<img src="/posts/cc605c90/image-20241230115121441.png" class="" title="image-20241230115121441">

<p>注意观察此时栈顶<code>esp</code>对应存储的值正是原始<code>ebp</code>值：直接<code>pop</code>即可<code>还原ebp</code>：如下：</p>
<img src="/posts/cc605c90/image-20241230115756173.png" class="" title="image-20241230115756173">

<p><strong><code>ebp</code>也就被还原到上一层栈的栈底</strong>，此时栈顶存储的也就是返回地址。</p>
<p><code>ret</code>指令，栈顶的值pop给<code>eip</code>：我们也就会进行一个跳转：如下：</p>
<img src="/posts/cc605c90/image-20241230120152524.png" class="" title="image-20241230120152524">

<p>但是现在我们还没能完全还原堆栈，因为还有如下内容：</p>
<img src="/posts/cc605c90/image-20241230120523409.png" class="" title="image-20241230120523409">

<p>于是我们就需要<code>add esp 14h</code>进行平栈操作。</p>
<p>上面就是比较经典的<code>_cdecl</code>函数调用约定的一个过程。</p>
<hr>

<h4 id="stdcall："><a href="#stdcall：" class="headerlink" title="_stdcall："></a>_stdcall：</h4><p>示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//强制转换成_stdcall</span></span><br><span class="line"><span class="function"><span class="type">int</span> _stdcall <span class="title">test</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c,<span class="type">int</span> d,<span class="type">int</span> f)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b + c + d + f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//_stdcall</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> nRes = <span class="built_in">test</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Res = %d \r\n&quot;</span>, nRes);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成exe然后拖入ida分析，如下：</p>
<img src="/posts/cc605c90/image-20241230123921684.png" class="" title="image-20241230123921684">

<p>我们通过观察会发现它和<code>_cdecl</code>有一个显著的区别，他调用完毕之后没有进行平栈操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">push    5               ; int</span><br><span class="line">push    4               ; int</span><br><span class="line">push    3               ; int</span><br><span class="line">push    2               ; int</span><br><span class="line">push    1               ; int</span><br><span class="line">call    _test</span><br></pre></td></tr></table></figure>

<p>接下来我们进入<code>test函数</code>内部进行一个分析看看：如下：</p>
<img src="/posts/cc605c90/image-20241230124154688.png" class="" title="image-20241230124154688">

<p>我们会发现其与<code>_cdecl</code>只有一个显著的不同，就是在最后是<code>retn 14h</code></p>
<p><code>retn 14h</code>是什么意思呢？</p>
<p>相当于在返回之前平掉堆栈里面的14h个字节，这就是其与<code>_cdecl</code>的不同之处，<code>_stdcall</code>是内平栈，<code>_cdecl</code>是外平栈。</p>
<h4 id="fastcall："><a href="#fastcall：" class="headerlink" title="_fastcall："></a>_fastcall：</h4><p><code>x86 debug</code></p>
<p>示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> _fastcall <span class="title">test</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c,<span class="type">int</span> d,<span class="type">int</span> f)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b + c + d + f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> nRes = <span class="built_in">test</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Res = %d \r\n&quot;</span>, nRes);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用x64dbg进行一手分析：运行到如下位置：</p>
<img src="/posts/cc605c90/image-20241230192407357.png" class="" title="image-20241230192407357">

<p>我们会发现他的参数不全是<code>push</code>，他是如下的结构：存入的参数</p>
<img src="/posts/cc605c90/image-20241230192715886.png" class="" title="image-20241230192715886">

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">;_fastcall:test函数内容</span><br><span class="line">push ebp</span><br><span class="line">mov ebp,esp</span><br><span class="line">sub esp,48</span><br><span class="line">push ebx</span><br><span class="line">push esi</span><br><span class="line">push edi </span><br><span class="line">;我们会发现他把两个参数放入了局部变量里面。</span><br><span class="line">mov dword ptr ss:[ebp-8],edx    </span><br><span class="line">mov dword ptr ss:[ebp-4],ecx</span><br><span class="line"></span><br><span class="line">mov ecx,funcrule.50F015</span><br><span class="line">call funcrule.44BE8C </span><br><span class="line">mov eax,dword ptr ss:[ebp-4]</span><br><span class="line">add eax,dword ptr ss:[ebp-8] </span><br><span class="line"></span><br><span class="line">;+号是参数，-号是局部变量</span><br><span class="line">add eax,dword ptr ss:[ebp+8]   </span><br><span class="line">add eax,dword ptr ss:[ebp+C]  </span><br><span class="line">add eax,dword ptr ss:[ebp+10] </span><br><span class="line">pop edi                         </span><br><span class="line">pop esi                         </span><br><span class="line">pop ebx                         </span><br><span class="line">mov esp,ebp                     </span><br><span class="line">pop ebp                         </span><br><span class="line">ret C                           </span><br></pre></td></tr></table></figure>

<p>这里自己调试调试看参数存放的位置就看明白了，或者可以自己画画堆栈图，就理解了。</p>
<h3 id="复杂结构分析："><a href="#复杂结构分析：" class="headerlink" title="复杂结构分析："></a>复杂结构分析：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_Res</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">&#125;Res;</span><br><span class="line"><span class="function">Res <span class="title">test</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d, <span class="type">int</span> f)</span> </span>&#123;</span><br><span class="line">	Res obj;</span><br><span class="line">	obj.a = a + b + c;</span><br><span class="line">	obj.b = d + f;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Res nRes = <span class="built_in">test</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Res = %d-%d \r\n&quot;</span>, nRes.a, nRes.b);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里堆栈结构不过多说，自己进行x64dbg的时候可以看看对应内存地址，以及堆栈的变化来分析。</p>
<p>可以写入更多变量来分析。</p>
<hr>

<h2 id="if-else语句识别分析：（第三天）"><a href="#if-else语句识别分析：（第三天）" class="headerlink" title="if-else语句识别分析：（第三天）"></a>if-else语句识别分析：（第三天）</h2><h3 id="01-if"><a href="#01-if" class="headerlink" title="01.if"></a>01.if</h3><p>示例代码1：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> nFlag = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;nFlag);</span><br><span class="line">	<span class="keyword">if</span> (nFlag == <span class="number">10</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Flag = %d&quot;</span>, nFlag);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后顺利生成如下四个版本的exe：<code>x64 debug</code>，<code>x86 debug</code>,<code>x64 release</code>，<code>x86 release</code></p>
<p>不过在有些环境下他运行报错了，如下：</p>
<img src="/posts/cc605c90/image-20241230212055697.png" class="" title="image-20241230212055697">

<p>我们对其进行一下如下设置，即可成功：</p>
<img src="/posts/cc605c90/image-20241230211958271.png" class="" title="image-20241230211958271">

<h4 id="分析：x86-debug版本如下"><a href="#分析：x86-debug版本如下" class="headerlink" title="分析：x86 debug版本如下"></a>分析：<code>x86 debug</code>版本如下</h4><p>首先将其拖入ida找到其主函数，进入主函数main：如下：</p>
<img src="/posts/cc605c90/image-20241230213026640.png" class="" title="image-20241230213026640">

<p>简单分析一下我们自己的功能函数代码：如下：</p>
<img src="/posts/cc605c90/image-20241230214708212.png" class="" title="image-20241230214708212">

<p>具体分析入戏：都在代码注释上：如下：</p>
<img src="/posts/cc605c90/image-20241230215212109.png" class="" title="image-20241230215212109">

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.text:00461922                 mov     [ebp+Var1], 0   ; Var1 = 0，这一部分开始就是我们自己代码</span><br><span class="line">.text:00461929                 lea     eax, [ebp+Var1] ; eax = &amp;Var1</span><br><span class="line">.text:0046192C                 push    eax             ; 压栈，可以理解为压入&amp;Var1</span><br><span class="line">.text:0046192D                 push    offset Format   ; 字符串：&quot;%d&quot;</span><br><span class="line">.text:00461932                 call    j__scanf</span><br><span class="line">.text:00461937                 add     esp, 8          ; 平栈2参数</span><br><span class="line">.text:0046193A                 cmp     [ebp+Var1], 0Ah ; 判断Var1与0Ah是否相等</span><br><span class="line">.text:0046193E                 jnz     short loc_461951 ; 如果不等就跳转推出，如果相等向下走</span><br><span class="line">.text:00461940                 mov     eax, [ebp+Var1] ; 将Var1的值给eax</span><br><span class="line">.text:00461943                 push    eax             ; 然后将eax进行压栈，push Var1</span><br><span class="line">.text:00461944                 push    offset aFlagD   ; &quot;Flag = %d&quot;</span><br><span class="line">.text:00461949                 call    j__printf</span><br><span class="line">.text:0046194E                 add     esp, 8          ; 平栈两个参数</span><br><span class="line">.text:00461951</span><br><span class="line">.text:00461951 loc_461951:                             ; CODE XREF: _main+4E↑j</span><br><span class="line">.text:00461951                 push    offset Command  ; &quot;pause&quot;</span><br><span class="line">.text:00461956                 call    j__system       ; 调用system</span><br></pre></td></tr></table></figure>

<h4 id="分析：x64-debug版本如下"><a href="#分析：x64-debug版本如下" class="headerlink" title="分析：x64 debug版本如下"></a>分析：<code>x64 debug</code>版本如下</h4><p>首先将其拖入ida找到其主函数，进入主函数main：如下：</p>
<img src="/posts/cc605c90/image-20241230220046475.png" class="" title="image-20241230220046475">

<p>自己可以分析一下不过多展示：如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.text:000000014007992B                 mov     [rbp+0F0h+Var1], 0</span><br><span class="line">.text:0000000140079932                 lea     rdx, [rbp+0F0h+Var1]</span><br><span class="line">.text:0000000140079936                 lea     rcx, Format     ; &quot;%d&quot;</span><br><span class="line">.text:000000014007993D                 call    j_scanf</span><br><span class="line">.text:0000000140079942                 cmp     [rbp+0F0h+Var1], 0Ah</span><br><span class="line">.text:0000000140079946                 jnz     short loc_140079957</span><br><span class="line">.text:0000000140079948                 mov     edx, [rbp+0F0h+Var1]</span><br><span class="line">.text:000000014007994B                 lea     rcx, aFlagD     ; &quot;Flag = %d\r\n&quot;</span><br><span class="line">.text:0000000140079952                 call    j_printf</span><br><span class="line">.text:0000000140079957</span><br><span class="line">.text:0000000140079957 loc_140079957:                          ; CODE XREF: main+56↑j</span><br><span class="line">.text:0000000140079957                 lea     rcx, Command    ; &quot;pause&quot;</span><br><span class="line">.text:000000014007995E                 call    j_system</span><br></pre></td></tr></table></figure>

<h3 id="02-if-else"><a href="#02-if-else" class="headerlink" title="02.if-else"></a>02.if-else</h3><p>示例代码2：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> nFlag = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;nFlag);</span><br><span class="line">	<span class="keyword">if</span> (nFlag == <span class="number">10</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Flag = %d\r\n&quot;</span>, nFlag);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Flag != 10&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后依旧是生成如下四个版本的exe：<code>x64 debug</code>，<code>x86 debug</code>,<code>x64 release</code>，<code>x86 release</code></p>
<h4 id="分析：x86-debug版本如下-1"><a href="#分析：x86-debug版本如下-1" class="headerlink" title="分析：x86 debug版本如下"></a>分析：<code>x86 debug</code>版本如下</h4><p>首先将其拖入ida找到其主函数，进入主函数main：如下：</p>
<img src="/posts/cc605c90/image-20241230233919770.png" class="" title="image-20241230233919770">

<p>我们会发现有一段汇编很特殊：如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.text:004618FC                 lea     edi, [ebp+var_D0]</span><br><span class="line">.text:00461902                 mov     ecx, 34h</span><br><span class="line">.text:00461907                 mov     eax, 0CCCCCCCCh</span><br><span class="line">.text:0046190C                 rep stosd</span><br></pre></td></tr></table></figure>

<p>我们来动态调试来分析一下：如下：</p>
<img src="/posts/cc605c90/image-20241230235417099.png" class="" title="image-20241230235417099">

<p>其就会将抬栈的部分全部刷新为0cccccccch。</p>
<p>下面我们来观察看，我们的main函数主体内容的汇编，也就是我们的<code>if-else</code>语句：如下：</p>
<img src="/posts/cc605c90/image-20241231000851119.png" class="" title="image-20241231000851119">

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mov dword ptr ss:[ebp-C],0      | [VarC]=0</span><br><span class="line">lea eax,dword ptr ss:[ebp-C]    | eax = &amp;Varc</span><br><span class="line">push eax                        | push eax</span><br><span class="line">push &lt;if_else.&quot;%d&quot;...&gt;          | BB9E50:&quot;%d&quot;</span><br><span class="line">call if_else.AFA99C             | scanf函数</span><br><span class="line">add esp,8                       | 平栈平两个参数</span><br><span class="line">cmp dword ptr ss:[ebp-C],A      | 判断Varc和10</span><br><span class="line">jne if_else.B01953              | 判断与10是否相等不相等则跳转</span><br><span class="line">mov eax,dword ptr ss:[ebp-C]    | eax = Varc</span><br><span class="line">push eax                        | push Varc</span><br><span class="line">push &lt;if_else.&quot;Flag = %d\r\n&quot;   | BB9E54:&quot;Flag = %d\r\n&quot;</span><br><span class="line">call if_else.AFA4C4             | printf</span><br><span class="line">add esp,8                       | 平栈两个参数</span><br><span class="line">jmp if_else.B01960              | 因为这里是if-else结构他在执行完if后会有一个无条件jmp</span><br><span class="line">push &lt;if_else.&quot;Flag != 10&quot;...   | main.cpp:14, BB9E64:&quot;Flag != 10&quot;</span><br><span class="line">call if_else.AFA4C4             |</span><br><span class="line">add esp,4                       |</span><br><span class="line">push &lt;if_else.&quot;pause&quot;...&gt;       | system函数入栈参数，BB9E74:&quot;pause&quot;</span><br></pre></td></tr></table></figure>

<h3 id="03-if-elseif-else"><a href="#03-if-elseif-else" class="headerlink" title="03.if-elseif-else"></a>03.if-elseif-else</h3><p>示例代码3：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> nFlag = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;nFlag);</span><br><span class="line">	<span class="keyword">if</span> (nFlag == <span class="number">10</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Flag = %d\r\n&quot;</span>, nFlag);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>  <span class="keyword">if</span> (nFlag == <span class="number">20</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Flag = %d\r\n&quot;</span>, nFlag);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Flag != 10&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后依旧是生成如下四个版本的exe：<code>x64 debug</code>，<code>x86 debug</code>,<code>x64 release</code>，<code>x86 release</code></p>
<h4 id="分析：x86-debug版本如下-2"><a href="#分析：x86-debug版本如下-2" class="headerlink" title="分析：x86 debug版本如下"></a>分析：<code>x86 debug</code>版本如下</h4><p>x64dbg分析其实和上面的大差不差关键点是要明白他的<code>jxx</code>的跳转逻辑注意观察：如下：</p>
<img src="/posts/cc605c90/image-20241231003125339.png" class="" title="image-20241231003125339">

<h3 id="04-多条件判断"><a href="#04-多条件判断" class="headerlink" title="04.多条件判断"></a>04.多条件判断</h3><p>示例代码4：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> nFlagA = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> nFlagB = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;nFlagA);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;nFlagB);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nFlagA == <span class="number">10</span> &amp;&amp; nFlagB == <span class="number">11</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Flag = %d %d\r\n&quot;</span>, nFlagA,nFlagB);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>  <span class="keyword">if</span> (nFlagA == <span class="number">20</span> || nFlagB == <span class="number">10</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Flag = %d %d\r\n&quot;</span>, nFlagA, nFlagB);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Flag != 10&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后依旧是生成如下四个版本的exe：<code>x64 debug</code>，<code>x86 debug</code>,<code>x64 release</code>，<code>x86 release</code></p>
<h4 id="分析：x86-debug版本如下-3"><a href="#分析：x86-debug版本如下-3" class="headerlink" title="分析：x86 debug版本如下"></a>分析：<code>x86 debug</code>版本如下</h4><p>x64dbg分析：</p>
<img src="/posts/cc605c90/image-20241231005014205.png" class="" title="image-20241231005014205">

<hr>

<h2 id="switch语句识别分析：（第四天）"><a href="#switch语句识别分析：（第四天）" class="headerlink" title="switch语句识别分析：（第四天）"></a>switch语句识别分析：（第四天）</h2><h3 id="01-switch-3case"><a href="#01-switch-3case" class="headerlink" title="01.switch-3case"></a>01.switch-3case</h3><p><code>无源码</code>版本分析：<code>x86 debug</code>:</p>
<p>分析：</p>
<p>main函数内容如下：</p>
 <img src="/posts/cc605c90/image-20250107195418619.png" class="" title="image-20250107195418619">

<p>后面我们会发现其有三个分支，满足条件就会跳转至不同的地址：如下：</p>
<img src="/posts/cc605c90/image-20250107195615305.png" class="" title="image-20250107195615305">

<img src="/posts/cc605c90/image-20250107200329296.png" class="" title="image-20250107200329296">



<p>其大致代码逻辑，<code>直翻</code>应该是如下这种的是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">VarC = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;VarC);</span><br><span class="line"><span class="keyword">if</span>(VarC === <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;nFlag == 1\n&quot;</span>);</span><br><span class="line">    <span class="keyword">goto</span> _ret; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(VarC === <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;nFlag == 2\n&quot;</span>);</span><br><span class="line">    <span class="keyword">goto</span> _ret; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(VarC === <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;nFlag == 3\n&quot;</span>);</span><br><span class="line">    <span class="keyword">goto</span> _ret; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_ret:</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>但是我们稍加思考我们就会发现它其实就是一个<code>switch</code>结构：如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">VarC = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;VarC);</span><br><span class="line"><span class="keyword">switch</span>(VarC)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;nFlag == 1\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;nFlag == 2\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;nFlag == 3\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;       </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h3 id="02-switch-6case"><a href="#02-switch-6case" class="headerlink" title="02.switch-6case"></a>02.switch-6case</h3><p>其与<code>3case</code>最大的区别就是有无<code>跳转表</code></p>
<p><code>无源码</code>版本分析：<code>x86 debug</code>:</p>
<p>首先进行一个初步观察如下图：</p>
<img src="/posts/cc605c90/image-20250107220751482.png" class="" title="image-20250107220751482">

<p>并且通过阅读汇编代码我们会发现，它有如下操作：（平索引）</p>
<img src="/posts/cc605c90/image-20250107221237182.png" class="" title="image-20250107221237182">

<p><strong>何为平索引，为什么要这么做呢？</strong></p>
<p>首先我们要了解一个概念，<code>跳转表</code>：</p>
<p><code>跳转表</code>是一个<code>数组</code>:</p>
<p>比方说我们来一个<code>case 10</code>这时候他要去数组里找到对应的需要跳转到的分支的地址。</p>
<p>因为在这个跳转表的<code>每一个索引</code>下都存的是<code>一个分支的地址</code>。 </p>
<p>理论上来说我们应该跳转到索引为10下存储的地址，但是我们知道的是数组的索引都是从0开始的。所以一开始的时候我们需要进行一个 <code>sub ecx,1</code>进行一个平索引的操作。</p>
<p><strong>其中<code>sub ecx,1</code>中的<code>1</code>不见的就是<code>1</code></strong>:</p>
<p>它是第一个case的值距离0有多远，然后强行把索引平到从0开始。</p>
<p>首先我们拿起和最大的索引进行一个cmp比较，ja的指令意思就是如果它大于5则跳转，跳出switch无法处理，如下图：</p>
<img src="/posts/cc605c90/image-20250107222545232.png" class="" title="image-20250107222545232">

<p>然后我们继续观察会发现这个，这个就是跳转表的关键内容：如下：</p>
<img src="/posts/cc605c90/image-20250107222830632.png" class="" title="image-20250107222830632">

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp     ds:jpt_461961[edx*4] ; switch jump</span><br></pre></td></tr></table></figure>

<p><code>jpt_461961</code>：这个是跳转表数组的首地址</p>
<p><code>edx</code>：索引</p>
<p><code>4</code>：size&#x3D;4</p>
<p>这个时候我们直接键盘输入<code>g</code>：如下：</p>
<img src="/posts/cc605c90/image-20250107223357631.png" class="" title="image-20250107223357631">

<p>然后在其中输入数组的首地址也就是：<code>jpt_461961</code>进行一个跳转：如下：</p>
<img src="/posts/cc605c90/image-20250107223613830.png" class="" title="image-20250107223613830">

<p>这里展示的就是一个实实在在的跳转表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.text:00461A1C jpt_461961      dd offset loc_461968    ; DATA XREF: _main_0+71↑r</span><br><span class="line">.text:00461A20                 dd offset loc_461977    ; jump table for switch statement</span><br><span class="line">.text:00461A24                 dd offset loc_461986</span><br><span class="line">.text:00461A28                 dd offset loc_461995</span><br><span class="line">.text:00461A2C                 dd offset loc_4619A4</span><br><span class="line">.text:00461A30                 dd offset loc_4619B3</span><br></pre></td></tr></table></figure>

<p>每一个都是<code>dd</code>也就是4字节。</p>
<p>其中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp     ds:jpt_461961[edx*4] ; switch jump</span><br></pre></td></tr></table></figure>

<p>它的意思就相当于是<code>首地址(00461A1C) + edx*4</code>。</p>
<p><code>loc_461986</code>就是真实分支所在位置。</p>
<p>比方说<code>3*4</code>:</p>
<p>也就是<code>首地址+C =  00461A28</code>：我们取出这个索引下对应的跳转地址：<code>00461995</code>我们按下<code>g</code>跳转到这个地址，如下：</p>
<img src="/posts/cc605c90/image-20250107224613598.png" class="" title="image-20250107224613598">

<p><strong>接下来我们来看看在动态调试时，这个跳转表长什么样子呢？</strong></p>
<img src="/posts/cc605c90/image-20250107225858903.png" class="" title="image-20250107225858903">

<p>其就是<code>首地址+索引*4</code>我们<code>ctrl+G</code>进行一下跳转到地址表位置：</p>
<img src="/posts/cc605c90/image-20250107230251144.png" class="" title="image-20250107230251144">

<p>不过要注意一点你要先行运行到此处才会有跳转表：如下：</p>
<img src="/posts/cc605c90/image-20250107235859852.png" class="" title="image-20250107235859852">

<p>输入3：</p>
<img src="/posts/cc605c90/image-20250107235914315.png" class="" title="image-20250107235914315">



<p>在这里他会有跳转表位置：如下：</p>
<img src="/posts/cc605c90/image-20250108000148339.png" class="" title="image-20250108000148339">

<p>将这个地址拿出来也就是首地址：如下：</p>
<img src="/posts/cc605c90/image-20250108000515826.png" class="" title="image-20250108000515826">

<p>我们在内存窗口直接<code>ctrl+g</code>输入这个地址转到，内存中的位置，<strong>这就是我们的跳转表的数组存储位置如下</strong>：如下：</p>
<img src="/posts/cc605c90/image-20250108000752636.png" class="" title="image-20250108000752636">

<p>其中存的就是汇编中对应索引需要跳转到的地址，是小端序。</p>
<h3 id="03-switch-6case缺项"><a href="#03-switch-6case缺项" class="headerlink" title="03.switch-6case缺项"></a>03.switch-6case缺项</h3><p><code>无源码</code>版本分析：<code>x86 debug</code>:</p>
<p>首先进行一个初步观察如下图：</p>
<p>我们会发现它识别出来了8个case:</p>
<img src="/posts/cc605c90/image-20250108001243509.png" class="" title="image-20250108001243509">

<p>他会给我们进行一个补齐，直接跳转到最后，相当于跳出switch：如下：</p>
<img src="/posts/cc605c90/image-20250108002044450.png" class="" title="image-20250108002044450">

<h3 id="04-switch-6case单项不连续"><a href="#04-switch-6case单项不连续" class="headerlink" title="04.switch-6case单项不连续"></a>04.switch-6case单项不连续</h3><p><code>无源码</code>版本分析：<code>x86 debug</code>:</p>
<p>首先进行一个初步观察，我们直接观察对应得比较部分，如下：</p>
<img src="/posts/cc605c90/image-20250108003256994.png" class="" title="image-20250108003256994">

<p>第一个判断其是不是大于888，如果大于直接跳出无法处理，也就是结束掉。</p>
<p>第二个判断其是不是就是888，如果等于则直接跳转到888对应的分支上去。</p>
<p>如果都不是那就继续往下走，也就是走正常的跳转表。也就五个分支。</p>
<h3 id="05-switch-6case多线表"><a href="#05-switch-6case多线表" class="headerlink" title="05.switch-6case多线表"></a>05.switch-6case多线表</h3><p>这个多线表里面有很多的不连续，它的跳转呢就有如下几种情况：如下：</p>
<img src="/posts/cc605c90/image-20250108004805680.png" class="" title="image-20250108004805680">

<p>继续往下走就是小于100的。</p>
<p>如若我们进入大于100的分支中，他还会有一个跳转表，如下：</p>
<img src="/posts/cc605c90/image-20250108005026786.png" class="" title="image-20250108005026786">

<p>我们可以进入这个跳转表内看看内容，如下：</p>
<img src="/posts/cc605c90/image-20250108005137392.png" class="" title="image-20250108005137392">

<p>如若我们进入等于100的分支中，则如下：</p>
<img src="/posts/cc605c90/image-20250108005243983.png" class="" title="image-20250108005243983">

<p>然后运行完毕，直接跳出switch。</p>
<p>如若我们进入小于100的分支中，我们可以观察其跳转表，如下：</p>
<img src="/posts/cc605c90/image-20250108005412214.png" class="" title="image-20250108005412214">



<p>由上面的例子我们可以看出，一个程序中未必只会有一个跳转表，它可以做一个分割，上面就做了如下分割：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;100</span><br><span class="line">=100</span><br><span class="line">&lt;100</span><br></pre></td></tr></table></figure>



<h3 id="06-switch-6case无线表无break"><a href="#06-switch-6case无线表无break" class="headerlink" title="06.switch-6case无线表无break"></a>06.switch-6case无线表无break</h3><p>这种情况下其没有跳转表，都是各跳个的基本，如下：</p>
<img src="/posts/cc605c90/image-20250108010328169.png" class="" title="image-20250108010328169">

<img src="/posts/cc605c90/image-20250108010500857.png" class="" title="image-20250108010500857">

<p>我们会发现其基本不连续，如果要形成<code>跳转表</code>其会形成大量的空项，会对资源造成极大的浪费。</p>
<hr>
## 循环结构识别分析：（第五天）

<h3 id="01-while循环"><a href="#01-while循环" class="headerlink" title="01.while循环"></a>01.while循环</h3><p>源码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> nFlag = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (nFlag &lt;= <span class="number">100</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;nFlag = %d\n&quot;</span>, nFlag);</span><br><span class="line">		nFlag++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析<code>x86 debug</code>：main函数主要内容如下：</p>
<img src="/posts/cc605c90/image-20250108160154796.png" class="" title="image-20250108160154796">

<p>我们直接对其汇编代码进行直译：如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Var8 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">_CmpCode:</span><br><span class="line"><span class="keyword">if</span>(Var8 &gt; <span class="number">100</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">goto</span> _EndCode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;nFlag = %d&quot;</span>, Var8);</span><br><span class="line">	Var8++;</span><br><span class="line">	<span class="keyword">goto</span> _CmpCode;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_EndCode:</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>经过整理可以整理成如下的模样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> Var8=<span class="number">0</span>; Var8 &lt;= <span class="number">100</span>; Var8++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;nFlag = %d&quot;</span>, Var8);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Var8 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(Var8 &lt;= <span class="number">100</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;nFlag = %d&quot;</span>, Var8);</span><br><span class="line">	Var8++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h3 id="02-for循环"><a href="#02-for循环" class="headerlink" title="02.for循环"></a>02.for循环</h3><p>源码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;nFlag = %d\n&quot;</span>, i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们直接分析<code>x86 debug</code>：main函数如下：</p>
<img src="/posts/cc605c90/image-20250108163654955.png" class="" title="image-20250108163654955">

<p>我们尝试直译，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">nIndex = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">goto</span> _CmpCode:</span><br><span class="line"></span><br><span class="line">_IncCode:</span><br><span class="line">nIndex++;</span><br><span class="line"></span><br><span class="line">_CmpCode:</span><br><span class="line"><span class="keyword">if</span>(nIndex &gt; <span class="number">100</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">goto</span> _EndCode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;nFlag = %d\n&quot;</span>,nIndex);</span><br><span class="line"> 	<span class="keyword">goto</span> _IncCode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_EndCode:</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>



<h3 id="03-dowhile循环"><a href="#03-dowhile循环" class="headerlink" title="03.dowhile循环"></a>03.dowhile循环</h3><p>源码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> nFlag = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;nFlag = %d\n&quot;</span>, nFlag);</span><br><span class="line">		nFlag++;</span><br><span class="line">	&#125; <span class="keyword">while</span> (nFlag &lt; <span class="number">100</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们分析<code>x86 debug</code>：main函数内容如下：</p>
<img src="/posts/cc605c90/image-20250108170031472.png" class="" title="image-20250108170031472">

<p>直译如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">nIndex = <span class="number">0</span>;</span><br><span class="line">_CmpCode:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;nFlag = %d \n&quot;</span>,nIndex);</span><br><span class="line">nIndex++;</span><br><span class="line"><span class="keyword">if</span>(nIndex &lt;= <span class="number">100</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">goto</span> _CmpCode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>优化成<code>do-while</code>的形式，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">nIndex = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;nFlag = %d \n&quot;</span>,nIndex);</span><br><span class="line">	nIndex++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(nIndex &lt;= <span class="number">100</span>)</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br></pre></td></tr></table></figure>

<h3 id="04-循环嵌套"><a href="#04-循环嵌套" class="headerlink" title="04.循环嵌套"></a>04.循环嵌套</h3><p>源码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">size_t</span> n = <span class="number">0</span>; n &lt; <span class="number">200</span>; n++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;i = %d:n = %d\n&quot;</span>, i, n);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接分析<code>x86 debug</code>：main如下：</p>
<img src="/posts/cc605c90/image-20250108171656421.png" class="" title="image-20250108171656421">

<p>直译汇编如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">nIndexA = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">goto</span> CmpCodeA;</span><br><span class="line"></span><br><span class="line">IncCodeA:</span><br><span class="line">	nIndexA++;</span><br><span class="line"></span><br><span class="line">CmpCodeA:</span><br><span class="line"><span class="keyword">if</span>(nIndexA &gt; <span class="number">100</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">goto</span> EndCode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    nIndexB = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">goto</span> CmpCodeB;</span><br><span class="line">    </span><br><span class="line">IncCodeB:</span><br><span class="line">    nIndexB++;</span><br><span class="line">    </span><br><span class="line">    CmpCodeB:</span><br><span class="line">    <span class="keyword">if</span>(nIndexB &gt; <span class="number">200</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> JmpACode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d:n = %d\n&quot;</span>,nIndexA,nIndexB);</span><br><span class="line">        <span class="keyword">goto</span> IncCodeB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JmpACode:</span><br><span class="line">	<span class="keyword">goto</span> IncCodeA;</span><br><span class="line"></span><br><span class="line">EndCode:</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h2 id="数组与指针识别分析：-第六天"><a href="#数组与指针识别分析：-第六天" class="headerlink" title="数组与指针识别分析：(第六天)"></a>数组与指针识别分析：(第六天)</h2><h3 id="01-函数内的数组"><a href="#01-函数内的数组" class="headerlink" title="01.函数内的数组"></a>01.函数内的数组</h3><h4 id="数组与多个同类型变量的区别："><a href="#数组与多个同类型变量的区别：" class="headerlink" title="数组与多个同类型变量的区别："></a><strong>数组与多个同类型变量的区别：</strong></h4><p>源码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> arr[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d,%d,%d,%d,%d\n&quot;</span>, arr[<span class="number">0</span>], arr[<span class="number">1</span>], arr[<span class="number">2</span>], arr[<span class="number">3</span>], arr[<span class="number">4</span>]);</span><br><span class="line">	<span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">	<span class="type">int</span> c = <span class="number">3</span>;</span><br><span class="line">	<span class="type">int</span> d = <span class="number">4</span>;</span><br><span class="line">	<span class="type">int</span> e = <span class="number">5</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d,%d,%d,%d,%d\n&quot;</span>, a, b, c, d, e);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>x86 debug</code>分析如下：</p>
<img src="/posts/cc605c90/image-20250108182612291.png" class="" title="image-20250108182612291">

<p>将这段连续的地址转换成数组：如下</p>
<img src="/posts/cc605c90/image-20250108182653342.png" class="" title="image-20250108182653342">

<p>然后点击OK即可。</p>
<p>然后我们回到汇编中它就会变成如下的样子：</p>
<img src="/posts/cc605c90/image-20250108182749045.png" class="" title="image-20250108182749045">

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov     [ebp+var_18], 1</span><br><span class="line">mov     [ebp+var_18+4], 2</span><br><span class="line">mov     [ebp+var_18+8], 3</span><br><span class="line">mov     [ebp+var_18+0Ch], 4</span><br><span class="line">mov     [ebp+var_18+10h], 5</span><br></pre></td></tr></table></figure>

<p><code>var_18</code>：数组首地址。</p>
<p>数组寻址：</p>
<p><code>数组首地址</code>+<code>offset(sizeof(type)) * index</code></p>
<p>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>数组下标就为：0,1,2,3,4</p>
<p>然后利用数组下标也就是他的索引 * type size：<code>offset(sizeof(type)) * index</code></p>
<p>至于后续的什么<code>shl</code>，<code>imul</code>都是为了算出他的对应地址，不用过多纠结。</p>
<p>我们只需要关注到，数组其在内存中是连续的即可。</p>
<p><strong>我们继续观察后面的同类型int变量：</strong>如下：</p>
<img src="/posts/cc605c90/image-20250108235410200.png" class="" title="image-20250108235410200">

<p>其与数组最大的区别就是他在内存中的位置并不是连续的，如下：</p>
<img src="/posts/cc605c90/image-20250108235515685.png" class="" title="image-20250108235515685">

<p>动态调试如下：</p>
<img src="/posts/cc605c90/image-20250108235914926.png" class="" title="image-20250108235914926">

<p>所以其在传参的时候也比较单纯，不用像上面一样需要计算相对地址什么的，直接就可以传其地址即可，如下：</p>
<img src="/posts/cc605c90/image-20250109000104525.png" class="" title="image-20250109000104525">

<p>这就是他们上面的一些差异。</p>
<h4 id="字符数组："><a href="#字符数组：" class="headerlink" title="字符数组："></a>字符数组：</h4><p>演示代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> szStr[] = &#123; <span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;v&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;r&#x27;</span> ,<span class="string">&#x27;\0&#x27;</span> &#125;;</span><br><span class="line">	<span class="type">char</span> szStr2[] = <span class="string">&quot;rkvir&quot;</span>;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面两种字符串，在内存中存储位置是不一样的，我们可以拖入ida观察一下：如下：</p>
<img src="/posts/cc605c90/image-20250109001022741.png" class="" title="image-20250109001022741">

<p>后者存储在数据段：如下：</p>
<img src="/posts/cc605c90/image-20250109001752008.png" class="" title="image-20250109001752008">

<p>按一下<code>a</code>就可以快捷自动识别出来了，如下：</p>
<img src="/posts/cc605c90/image-20250109001857979.png" class="" title="image-20250109001857979">

<h3 id="02-数组作为参数"><a href="#02-数组作为参数" class="headerlink" title="02.数组作为参数"></a>02.数组作为参数</h3><p>演示代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showArr</span><span class="params">(<span class="type">char</span> buffer[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> szStr[] = &#123; <span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;v&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;r&#x27;</span> ,<span class="string">&#x27;\0&#x27;</span> &#125;;</span><br><span class="line">	<span class="built_in">showArr</span>(szStr);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="x86-debug：分析"><a href="#x86-debug：分析" class="headerlink" title="x86 debug：分析"></a><code>x86 debug</code>：分析</h4><p>动态调试找到main函数位置：如下：</p>
<img src="/posts/cc605c90/image-20250109002612552.png" class="" title="image-20250109002612552">

<p>[ebp-10]这个位置正是数组头也就是首地址：如下</p>
<img src="/posts/cc605c90/image-20250109002838007.png" class="" title="image-20250109002838007">

<p>将这个字符串的首地址存入了eax中：如下：</p>
<img src="/posts/cc605c90/image-20250109003112619.png" class="" title="image-20250109003112619">

<p>它后面紧接着调用来一个函数，这个函数正是我们自定义的函数<code>showArr</code>：</p>
<p>通过观察我们发现它传参不是说像其他传参一样压入一个值，<strong>它直接是压入了字符串数组的首地址进入函数中</strong>。</p>
<h4 id="x64-debug：分析"><a href="#x64-debug：分析" class="headerlink" title="x64 debug：分析"></a><code>x64 debug</code>：分析</h4><p>动态调试找到main函数位置：如下：</p>
<img src="/posts/cc605c90/image-20250109004625259.png" class="" title="image-20250109004625259">

<p>因为64位的程序函数调用约定执行的是<code>_fastcall</code>的所以它传如函数的方式是前四个参数都是放入寄存器中的。所以它在传参的时候是将首地址存入了寄存器中，如上图所示。</p>
<h3 id="03-数组作为返回值"><a href="#03-数组作为返回值" class="headerlink" title="03.数组作为返回值"></a>03.数组作为返回值</h3><p>演示代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">char</span> * <span class="title">showArr</span><span class="params">(<span class="type">char</span> buffer[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memcpy</span>(buffer, <span class="string">&quot;HelloWorld&quot;</span>, <span class="number">11</span>);</span><br><span class="line">	<span class="keyword">return</span> buffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> buffer[<span class="number">20</span>];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, <span class="built_in">showArr</span>(buffer));</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和02的情况差不太多。</p>
<p>main函数下目标函数位置如下：</p>
<img src="/posts/cc605c90/image-20250109010006474.png" class="" title="image-20250109010006474">

<p>下面第一个函数是<code>printf</code>函数。</p>
<p>总结就是，数组在函数之间传递直接传递的都是一个地址，也就是自己的首地址。可以自己动态调试去分析，不断的观察内存和堆栈之中的变化情况。</p>
<h3 id="04-下标和指针寻址"><a href="#04-下标和指针寻址" class="headerlink" title="04.下标和指针寻址"></a>04.下标和指针寻址</h3><p>演示代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> * p = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">char</span> buffer[] = <span class="string">&quot;H ello&quot;</span>;</span><br><span class="line">	p = buffer;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, *p);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, buffer[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态调试，我们自己的位置位于：如下：</p>
<h4 id="指针寻址："><a href="#指针寻址：" class="headerlink" title="指针寻址："></a>指针寻址：</h4><img src="/posts/cc605c90/image-20250109011831517.png" class="" title="image-20250109011831517">

<p>这里我们直接将<code>hell</code>存入堆栈中的<code>ebp-1C</code>中，如下：</p>
<img src="/posts/cc605c90/image-20250109014407073.png" class="" title="image-20250109014407073">

<p>然后将其存入eax中，并将<code>o</code>存入cx中：如下：</p>
<img src="/posts/cc605c90/image-20250109014636374.png" class="" title="image-20250109014636374">

<p>他将其地址存入栈内：如下：</p>
<img src="/posts/cc605c90/image-20250109015112309.png" class="" title="image-20250109015112309">

<p>最后大概造成如下效果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">char buffer[] = &quot;H ello&quot;;</span><br><span class="line">对应的就是：</span><br><span class="line">mov eax,dword ptr ds:[A97E50]    | eax:&quot;Hello&quot;, 00A97E50:&quot;Hello&quot;</span><br><span class="line">mov dword ptr ss:[ebp-1C],eax    |</span><br><span class="line">mov cx,word ptr ds:[A97E54]      |</span><br><span class="line">mov word ptr ss:[ebp-18],cx      |</span><br><span class="line"></span><br><span class="line">p = buffer;</span><br><span class="line">对应的就是：</span><br><span class="line">mov dword ptr ss:[ebp-C],eax     | [ebp-0C]:&quot;Hello&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*p</span><br><span class="line">对应的就是：</span><br><span class="line">mov eax,dword ptr ss:[ebp-C]     | [ebp-0C]:&quot;Hello&quot;</span><br><span class="line">movsx ecx,byte ptr ds:[eax]      | eax:&quot;Hello&quot;</span><br><span class="line">;这一段就会取出这段地址为起点，宽度为8bit的数据，也就是一字节也就是H</span><br></pre></td></tr></table></figure>

<img src="/posts/cc605c90/image-20250109020151483.png" class="" title="image-20250109020151483">

<p>上述就是指针寻址。</p>
<h4 id="下标寻址："><a href="#下标寻址：" class="headerlink" title="下标寻址："></a>下标寻址：</h4><p>主要代码位于如下：</p>
<p>注意此处：首地址是<code>ebp-1C</code>，<code>ecx</code>代表的是<code>索引*typesize</code></p>
<img src="/posts/cc605c90/image-20250109020513962.png" class="" title="image-20250109020513962">

<img src="/posts/cc605c90/image-20250109020615043.png" class="" title="image-20250109020615043">

<h3 id="05-多维数组"><a href="#05-多维数组" class="headerlink" title="05.多维数组"></a>05.多维数组</h3><p>演示代码1如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//一维数组</span></span><br><span class="line">	<span class="type">int</span> a[<span class="number">4</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line">    <span class="comment">//二维数组</span></span><br><span class="line">	<span class="type">int</span> b[<span class="number">2</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125; &#125;;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, b[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候我们就要看一下了他们在内存中有什么区别。</p>
<p><code>x86 debug</code>分析如下：</p>
<img src="/posts/cc605c90/image-20250110203423060.png" class="" title="image-20250110203423060">

<p>我们可以看看他们在内存中的位置：如下：</p>
<p>一维数组：</p>
<img src="/posts/cc605c90/image-20250110203844097.png" class="" title="image-20250110203844097">

<p>二维数组：</p>
<img src="/posts/cc605c90/image-20250110204002900.png" class="" title="image-20250110204002900">

<p>通过实际观察可知，就存储而言一维数组和二维数组是没有变化的，他们在内存中都是连续存储的。本质上二者并无差别。</p>
<h4 id="二维数组的寻址方式："><a href="#二维数组的寻址方式：" class="headerlink" title="二维数组的寻址方式："></a>二维数组的寻址方式：</h4><p><code>a[i]:</code></p>
<p><strong>寻址公式</strong> &#x3D; <code>首地址 +  i*typesize</code></p>
<p><code>a[i][j]:</code></p>
<p><strong>寻址公式</strong> &#x3D;<code> (首地址 + j*typesize) + i*(typesize*j)</code></p>
<p>对于二维数组的寻址公式可以这么理解，先找到第 j 列的地址以后，再根据确定下来的新首地址找第 i 行地址。</p>
<p>第 j 列：<strong>新首地址 &#x3D; 首地址 + j*typesize</strong></p>
<p>此时新数组的大小也变了变成了 <strong>新typesize &#x3D; j * typesize</strong></p>
<p>第 i 行：<strong>地址 &#x3D; 新首地址 + i * 新typesize</strong></p>
<p>也就是：<strong>寻址公式</strong> &#x3D;<code> (首地址 + j*typesize) + i*(typesize*j)</code></p>
<p><strong>补充：</strong></p>
<p>二维数组的内存布局通常是按行优先（Row-major order）存储的，即将每一行的元素顺序地存储在内存中。数组在内存中的布局如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">arr<span class="selector-attr">[0]</span><span class="selector-attr">[0]</span>  arr<span class="selector-attr">[0]</span><span class="selector-attr">[1]</span>  arr<span class="selector-attr">[0]</span><span class="selector-attr">[2]</span>  arr<span class="selector-attr">[0]</span><span class="selector-attr">[3]</span></span><br><span class="line">  |          |          |          |</span><br><span class="line">  ↓          ↓          ↓          ↓</span><br><span class="line"><span class="number">0</span>x1000     <span class="number">0</span>x1004     <span class="number">0</span>x1008     <span class="number">0</span>x100C</span><br><span class="line"></span><br><span class="line">arr<span class="selector-attr">[1]</span><span class="selector-attr">[0]</span>  arr<span class="selector-attr">[1]</span><span class="selector-attr">[1]</span>  arr<span class="selector-attr">[1]</span><span class="selector-attr">[2]</span>  arr<span class="selector-attr">[1]</span><span class="selector-attr">[3]</span></span><br><span class="line">  |          |          |          |</span><br><span class="line">  ↓          ↓          ↓          ↓</span><br><span class="line"><span class="number">0</span>x1010     <span class="number">0</span>x1014     <span class="number">0</span>x1018     <span class="number">0</span>x101C</span><br><span class="line"></span><br><span class="line">arr<span class="selector-attr">[2]</span><span class="selector-attr">[0]</span>  arr<span class="selector-attr">[2]</span><span class="selector-attr">[1]</span>  arr<span class="selector-attr">[2]</span><span class="selector-attr">[2]</span>  arr<span class="selector-attr">[2]</span><span class="selector-attr">[3]</span></span><br><span class="line">  |          |          |          |</span><br><span class="line">  ↓          ↓          ↓          ↓</span><br><span class="line"><span class="number">0</span>x1020     <span class="number">0</span>x1024     <span class="number">0</span>x1028     <span class="number">0</span>x102C</span><br></pre></td></tr></table></figure>

<h4 id="行优先存储（Row-major-order）"><a href="#行优先存储（Row-major-order）" class="headerlink" title="行优先存储（Row-major order）"></a>行优先存储（Row-major order）</h4><p>二维数组在内存中是按行优先顺序存储的。在访问二维数组元素时，计算地址的方式与一维数组类似，但需要考虑行和列的索引。假设有一个 <code>m x n</code> 的二维数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr[m][n]</span><br></pre></td></tr></table></figure>

<p>对于元素 <code>arr[i][j]</code>，它的内存地址可以通过以下公式计算：</p>
<p><code>地址 = 基址 + (i * n + j) * 元素大小</code></p>
<p>其中：</p>
<ul>
<li><code>i</code> 是行的索引</li>
<li><code>j</code> 是列的索引</li>
<li><code>n</code> 是每行的元素数量</li>
<li><code>元素大小</code> 是数组中每个元素的字节数</li>
</ul>
<p>通过观察我们的程序：如下：</p>
<p>我们会发现它进行了两次运算和我们上面所说一致。</p>
<img src="/posts/cc605c90/image-20250110211613050.png" class="" title="image-20250110211613050">

<h3 id="06-指针数组"><a href="#06-指针数组" class="headerlink" title="06.指针数组"></a>06.指针数组</h3><p>演示代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> * buffer1 = <span class="string">&quot;h1111&quot;</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> * buffer2 = <span class="string">&quot;h2222&quot;</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> * buffer3 = <span class="string">&quot;h3333&quot;</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> * buffer4 = <span class="string">&quot;h4444&quot;</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> * arr[] = &#123; buffer1,buffer2 ,buffer3 ,buffer4 &#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>x86 debug </code>调试分析一手：如下</p>
<img src="/posts/cc605c90/image-20250110214836600.png" class="" title="image-20250110214836600">

<h3 id="07-数组指针"><a href="#07-数组指针" class="headerlink" title="07.数组指针"></a>07.数组指针</h3><p>代码演示如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">3</span>][<span class="number">3</span>] = &#123; &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125; &#125;;</span><br><span class="line">	<span class="built_in">int</span>(*p)[<span class="number">3</span>] = a;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">size_t</span> x = <span class="number">0</span>; x &lt; <span class="number">3</span>; x++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p[i][x]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们主要观察这一段：如下：</p>
<img src="/posts/cc605c90/image-20250110221920269.png" class="" title="image-20250110221920269">

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mov dword ptr ss:[ebp-2C],1</span><br><span class="line">mov dword ptr ss:[ebp-28],2</span><br><span class="line">mov dword ptr ss:[ebp-24],3</span><br><span class="line">mov dword ptr ss:[ebp-20],4</span><br><span class="line">mov dword ptr ss:[ebp-1C],5</span><br><span class="line">mov dword ptr ss:[ebp-18],6</span><br><span class="line">mov dword ptr ss:[ebp-14],7</span><br><span class="line">mov dword ptr ss:[ebp-10],8</span><br><span class="line">mov dword ptr ss:[ebp-C],9</span><br><span class="line"></span><br><span class="line">;这一段的作用正好对应代码中的：</span><br><span class="line">;int a[3][3] = &#123; &#123;1,2,3&#125;,&#123;4,5,6&#125;,&#123;7,8,9&#125; &#125;;</span><br><span class="line"></span><br><span class="line">lea eax,dword ptr ss:[ebp-2C]</span><br><span class="line">mov dword ptr ss:[ebp-38],eax           |</span><br><span class="line">;这一段的作用正好对应代码中的：</span><br><span class="line">;int(*p)[3] = a;</span><br><span class="line">;其中这个[ebp - 38]正是对应我们的指针</span><br></pre></td></tr></table></figure>

<p>接下来我们来进一步分析一下内层代码：如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">imul eax,dword ptr ss:[ebp-44],C        </span><br><span class="line">;将C*[ebp-44]的值存储进寄存器eax中:其中C是单个元素(一维数组)的数据宽度。</span><br><span class="line">;[ebp-44]代表的是索引</span><br><span class="line">;这里就是利用我们的外层索引来判断我们当前处于哪一个一维数组</span><br><span class="line">add eax,dword ptr ss:[ebp-38]           </span><br><span class="line">;这里的[ebp-38]存储的正是我们的首地址</span><br><span class="line">;加上以后就成功确定我们的数组在哪了</span><br><span class="line">;这时候新的首地址也就是我们当前所处一维数组的首地址！（也就是eax）</span><br><span class="line"></span><br><span class="line">mov ecx,dword ptr ss:[ebp-50]</span><br><span class="line">;[ebp-50]是我们的内层的索引，赋值给ecx了</span><br><span class="line">mov edx,dword ptr ds:[eax+ecx*4]</span><br><span class="line">;因为我们已经确定了具体是哪个数组，并且上面已经将其首地址取出了，想要取出其中某个具体的值只需要利用公式即可</span><br><span class="line">;符合二维数组的寻址公式： 新首地址 + 索引*(内层数据的数据宽度)</span><br><span class="line">;地址 = 新首地址(eax) + 内层索引(ecx) * 4(typesize(int)) = eax+ecx*4</span><br><span class="line"></span><br><span class="line">push edx </span><br><span class="line">push arr.417E50    ;压入格式化字符串</span><br><span class="line">call printf    ;调用printf函数</span><br><span class="line">add esp,8	;	平栈</span><br></pre></td></tr></table></figure>

<p>解释一下为什么要乘以C:</p>
<p><code>int a[3][3] = &#123; &#123;1,2,3&#125;,&#123;4,5,6&#125;,&#123;7,8,9&#125; &#125;</code></p>
<p>这是我们自己的代码，这个二维数组其可以看作是一个一维数组里面存储了一个一维数组，而存储的这个一维数组是由三个int型变量组成。</p>
<p>所以这单个<code>&#123;1,2,3&#125;</code>也就是，<code>3 * typesize(int) = C</code>所以也就可以理解成，<strong>这个一维数组，这个数据宽度是C</strong>，也就是<strong>新的typesize</strong>，这里我上面写多维数组笔记的时候有记录到。</p>
<h3 id="08-函数指针"><a href="#08-函数指针" class="headerlink" title="08.函数指针"></a>08.函数指针</h3><p>演示代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * szStr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, szStr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*MyShow)</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * szStr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyShow func = show;</span><br><span class="line">	<span class="built_in">func</span>(<span class="string">&quot;rkvir&quot;</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看看主函数main分析一手：如下：</p>
<img src="/posts/cc605c90/image-20250110232518297.png" class="" title="image-20250110232518297">

<p>我们跟进去发现其就是一个函数跳转表：如下：</p>
<img src="/posts/cc605c90/image-20250110232625504.png" class="" title="image-20250110232625504">

<p>跟进去就会发现这其实就是我们的show函数：如下：</p>
<img src="/posts/cc605c90/image-20250110232713008.png" class="" title="image-20250110232713008">

<p>后续我们会发现其会call了这个<code>[ebp - 8]</code>，也就会自动跳转到我们的这个show函数。上面正是我们的函数指针的一个调用过程：</p>
<p><strong>将函数的地址放到一个变量里，然后我们去call这个变量。</strong></p>
<h2 id="类与对象的识别分析：-第七天"><a href="#类与对象的识别分析：-第七天" class="headerlink" title="类与对象的识别分析：(第七天)"></a>类与对象的识别分析：(第七天)</h2><h3 id="01-对象布局"><a href="#01-对象布局" class="headerlink" title="01.对象布局"></a>01.对象布局</h3><h4 id="未继承对象布局"><a href="#未继承对象布局" class="headerlink" title="未继承对象布局"></a>未继承对象布局</h4><p>演示源码：obj.cpp:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">rkvir</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">rkvir</span>();</span><br><span class="line">	~<span class="built_in">rkvir</span>();</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">geta</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getb</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">MyStruct</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> c;</span><br><span class="line">		<span class="type">int</span> d;</span><br><span class="line">	&#125;;</span><br><span class="line">	MyStruct m;</span><br><span class="line">	<span class="type">short</span> e;</span><br><span class="line">	<span class="type">int</span> f;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">rkvir::<span class="built_in">rkvir</span>()</span><br><span class="line">&#123;</span><br><span class="line">	b = <span class="number">200</span>;</span><br><span class="line">	a = <span class="number">100</span>;</span><br><span class="line">	m.c = <span class="number">200</span>;</span><br><span class="line">	m.d = <span class="number">300</span>;</span><br><span class="line">	e = <span class="number">50</span>;</span><br><span class="line">	f = <span class="number">500</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rkvir::~<span class="built_in">rkvir</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rkvir::geta</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rkvir::getb</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	rkvir rk;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>静态调试分析：</strong></p>
<p>我们自己的主要代码就在这一部分：如下</p>
<img src="/posts/cc605c90/image-20250111001413495.png" class="" title="image-20250111001413495">

<p>其中这个var_20就是我们的<code>object</code>对象地址：我们的main函数中主要就只有实例化了一个对象：</p>
<p>C++中我们实例化一个对象，就会马上执行其中的构造函数，将对象的各个属性进行一个初始化。</p>
<p>并且我们能够发现其在调用函数之前会进行一个地址传递的操作，这也是一种调用约定<code>_thiscall</code>。</p>
<p>根据上图也可知，构造函数的地址正是<code>sub_450743</code>：进入这个函数可以看到其主要代码，如下：</p>
<img src="/posts/cc605c90/image-20250111001908499.png" class="" title="image-20250111001908499">

<p>通过我们自己的C++代码对照，也可知这段代码进行了一个赋值操作：</p>
<p><strong>这里的var_8在构造函数内部起到一个<code>this</code>的作用，相当于是一个指向我们对象的指针。</strong></p>
<p>然后返回我们会发现，他还调用了一个函数<code>sub_45114D</code>，这个函数正是C++特有的析构函数，用于在函数结束以后销毁对象的。</p>
<p><strong>动态调试分析：</strong></p>
<p>找到我们自己的主函数位置：如下：</p>
<img src="/posts/cc605c90/image-20250111002538344.png" class="" title="image-20250111002538344">

<p>找到构造函数调用特征了<code>lea</code>，直接进入构造函数内：如下：</p>
<img src="/posts/cc605c90/image-20250111003111335.png" class="" title="image-20250111003111335">

<p>可以看到<code>eax</code>存储的就是我们生成对象的首地址，他其实就是内部函数的一个this指针，指向我们的对象首地址，(但他本身并不是对象，只是指向我们已经实例化的对象首地址)对照着右下角的堆栈进行观察，如下：</p>
<img src="/posts/cc605c90/image-20250111003858205.png" class="" title="image-20250111003858205">

<img src="/posts/cc605c90/image-20250111004401552.png" class="" title="image-20250111004401552">

<p>可以自己在看这段笔记的时候再对照着调试一番。</p>
<h4 id="继承后对象布局"><a href="#继承后对象布局" class="headerlink" title="继承后对象布局"></a>继承后对象布局</h4><p>演示源码：virtual.cpp:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">rkvir</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">rkvir</span>();</span><br><span class="line">	~<span class="built_in">rkvir</span>();</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">geta</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getb</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//函数继承</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">MyStruct</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> c;</span><br><span class="line">		<span class="type">int</span> d;</span><br><span class="line">	&#125;;</span><br><span class="line">	MyStruct m;</span><br><span class="line">	<span class="type">short</span> e;</span><br><span class="line">	<span class="type">int</span> f;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">rkvir::<span class="built_in">rkvir</span>()</span><br><span class="line">&#123;</span><br><span class="line">	b = <span class="number">200</span>;</span><br><span class="line">	a = <span class="number">100</span>;</span><br><span class="line">	m.c = <span class="number">200</span>;</span><br><span class="line">	m.d = <span class="number">300</span>;</span><br><span class="line">	e = <span class="number">50</span>;</span><br><span class="line">	f = <span class="number">500</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rkvir::~<span class="built_in">rkvir</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rkvir::geta</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rkvir::getb</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">xxx</span>:<span class="keyword">public</span> rkvir</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">xxx</span>();</span><br><span class="line">	~<span class="built_in">xxx</span>();</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xxx::<span class="built_in">xxx</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">xxx::~<span class="built_in">xxx</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">xxx::show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;rkvir&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	rkvir rk;</span><br><span class="line">	xxx mx;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>xxx</code>继承了<code>rkvir</code></p>
<p>我们看看静态的汇编代码，如下：</p>
<img src="/posts/cc605c90/image-20250111182953411.png" class="" title="image-20250111182953411">

<p>我们可以跟进第一个构造函数内部看看，如下：</p>
<img src="/posts/cc605c90/image-20250111183241277.png" class="" title="image-20250111183241277">

<p>第二个构造函数内部，如下：</p>
<img src="/posts/cc605c90/image-20250111183354228.png" class="" title="image-20250111183354228">

<p>黄色标注部分就是他的虚函数表的地址：</p>
<h5 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h5><p>虚函数表（vtable，Virtual Table）是面向对象编程中用于支持<strong>动态绑定</strong>（也称为<strong>多态</strong>）的一种机制。它主要与C++等支持多态的语言相关。为了让程序能够在运行时根据对象的实际类型调用正确的虚函数，虚函数表在后台起着关键作用。</p>
<h5 id="虚函数表的工作原理："><a href="#虚函数表的工作原理：" class="headerlink" title="虚函数表的工作原理："></a>虚函数表的工作原理：</h5><ol>
<li><strong>虚函数的声明：</strong> 在类中，如果某个成员函数被声明为<code>virtual</code>，编译器就会为该类生成一个虚函数表。虚函数表是一个指针数组，数组中的每个元素指向类中的一个虚函数。</li>
<li><strong>继承和覆盖：</strong> 当一个类继承另一个类并重写了某个虚函数时，子类会用自己的函数覆盖父类的虚函数。在虚函数表中，指向父类虚函数的指针会被替换成指向子类虚函数的指针。</li>
<li><strong>对象和虚函数表的关联：</strong> 每个对象（或其子类对象）都会持有一个指向虚函数表的指针。这个指针通常作为对象的一部分存储在内存中，当调用虚函数时，程序会通过该指针找到相应的虚函数表，进而调用正确的函数。</li>
<li><strong>多态的实现：</strong> 通过虚函数表的机制，C++支持<strong>动态多态</strong>。即使你只有基类的指针或引用，在实际调用虚函数时，程序会根据对象的实际类型（不是声明类型）来决定调用哪个版本的虚函数。</li>
</ol>
<p>接下来我们<strong>动态调试</strong>来看看：这个<code>续函数表</code></p>
<img src="/posts/cc605c90/image-20250111191900093.png" class="" title="image-20250111191900093">

<p>上面存储的只是一个指向虚函数表的指针。</p>
<p>我们可以在内存中看到其真实虚函数表地址：如下：</p>
<img src="/posts/cc605c90/image-20250111192214215.png" class="" title="image-20250111192214215">

<p>跳转到虚函数表：如下：</p>
<img src="/posts/cc605c90/image-20250111192318027.png" class="" title="image-20250111192318027">

<p>跳转进来正是继承的函数：如下：</p>
<img src="/posts/cc605c90/image-20250111192439889.png" class="" title="image-20250111192439889">



<h3 id="02-this指针"><a href="#02-this指针" class="headerlink" title="02.this指针"></a>02.this指针</h3><p>演示源代码：this.cpp:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">rkvir</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">rkvir</span>();</span><br><span class="line">	~<span class="built_in">rkvir</span>();</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">geta</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getb</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">seta</span><span class="params">(<span class="type">int</span> a)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">MyStruct</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> c;</span><br><span class="line">		<span class="type">int</span> d;</span><br><span class="line">	&#125;;</span><br><span class="line">	MyStruct m;</span><br><span class="line">	<span class="type">short</span> e;</span><br><span class="line">	<span class="type">int</span> f;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">rkvir::<span class="built_in">rkvir</span>()</span><br><span class="line">&#123;</span><br><span class="line">	b = <span class="number">200</span>;</span><br><span class="line">	a = <span class="number">100</span>;</span><br><span class="line">	m.c = <span class="number">200</span>;</span><br><span class="line">	m.d = <span class="number">300</span>;</span><br><span class="line">	e = <span class="number">50</span>;</span><br><span class="line">	f = <span class="number">500</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rkvir::~<span class="built_in">rkvir</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rkvir::geta</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rkvir::getb</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rkvir::seta</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">xxx</span>:<span class="keyword">public</span> rkvir</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">xxx</span>();</span><br><span class="line">	~<span class="built_in">xxx</span>();</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xxx::<span class="built_in">xxx</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">xxx::~<span class="built_in">xxx</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">xxx::show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;rkvir&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	rkvir rk;</span><br><span class="line">	rk.<span class="built_in">seta</span>(<span class="number">4</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来拉入ida观察分析一番，如下：</p>
<img src="/posts/cc605c90/image-20250111210537157.png" class="" title="image-20250111210537157">

<p>我们直接进入第二个<code>call sub_4524EE</code>，如下：</p>
<img src="/posts/cc605c90/image-20250111210719025.png" class="" title="image-20250111210719025">

<p>它就是进行了一个简单的对象内部属性的赋值操作。</p>
<p><strong>动态调试分析：</strong></p>
<p>首先我们进入其main函数位置，并在其内存窗口转到对象空间，如下：</p>
<img src="/posts/cc605c90/image-20250111212816185.png" class="" title="image-20250111212816185">

<p>随后进入这个后续的函数中来：如下：</p>
<img src="/posts/cc605c90/image-20250111212942064.png" class="" title="image-20250111212942064">

<p>我们代码位于：如下位置：</p>
<img src="/posts/cc605c90/image-20250111213037408.png" class="" title="image-20250111213037408">

<p>可以看到它首先将对象空间<code>首地址</code>赋值给了<code>eax</code>，然后再将传入的<code>参数4</code>赋值给了<code>ecx</code>，最后将值4赋给了对象中对应的属性。</p>
<p>达到了一个修改的作用如下：</p>
<img src="/posts/cc605c90/image-20250111213918162.png" class="" title="image-20250111213918162">





<h3 id="03-使用对象作为函数参数及返回值"><a href="#03-使用对象作为函数参数及返回值" class="headerlink" title="03.使用对象作为函数参数及返回值"></a>03.使用对象作为函数参数及返回值</h3><p>演示代码如下：project13.cpp：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">rkvir</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">rkvir</span>();</span><br><span class="line">	~<span class="built_in">rkvir</span>();</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">geta</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getb</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">seta</span><span class="params">(<span class="type">int</span> a)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">MyStruct</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> c;</span><br><span class="line">		<span class="type">int</span> d;</span><br><span class="line">	&#125;;</span><br><span class="line">	MyStruct m;</span><br><span class="line">	<span class="type">short</span> e;</span><br><span class="line">	<span class="type">int</span> f;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">rkvir::<span class="built_in">rkvir</span>()</span><br><span class="line">&#123;</span><br><span class="line">	b = <span class="number">200</span>;</span><br><span class="line">	a = <span class="number">100</span>;</span><br><span class="line">	m.c = <span class="number">200</span>;</span><br><span class="line">	m.d = <span class="number">300</span>;</span><br><span class="line">	e = <span class="number">50</span>;</span><br><span class="line">	f = <span class="number">500</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rkvir::~<span class="built_in">rkvir</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rkvir::geta</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rkvir::getb</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rkvir::seta</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">xxx</span>:<span class="keyword">public</span> rkvir</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">xxx</span>();</span><br><span class="line">	~<span class="built_in">xxx</span>();</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xxx::<span class="built_in">xxx</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">xxx::~<span class="built_in">xxx</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">xxx::show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;rkvir&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">rkvir <span class="title">rkprint</span><span class="params">(rkvir xx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, xx.<span class="built_in">getb</span>());</span><br><span class="line">	xx.<span class="built_in">seta</span>(<span class="number">500</span>);</span><br><span class="line">	<span class="keyword">return</span> xx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	rkvir rk;</span><br><span class="line">	rkvir rk2;</span><br><span class="line">	rk2 = <span class="built_in">rkprint</span>(rk);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, rk<span class="number">2.</span><span class="built_in">geta</span>());</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先找到main函数：如下：</p>
<img src="/posts/cc605c90/image-20250111230000382.png" class="" title="image-20250111230000382">

<p>主要是看这个点会比较特殊：如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lea     eax, [ebp+objrk] ; rk对象地址给到eax，然后压栈，作为参数传入拷贝构造函数</span><br><span class="line">push    eax</span><br><span class="line">call    sub_4524F3      ; 拷贝构造函数</span><br></pre></td></tr></table></figure>

<p>它调用的<code>sub_4524F3</code>函数在我们的代码中并未出现：他其实是一个<strong>拷贝构造函数</strong>，他会将我们即将传入的对象<code>objrk</code>进行一个拷贝，拷贝以后将拷贝后的对象传入，下一个函数当中也就是<code>rk2 = rkprint(rk);</code></p>
<p>我们来看看这个函数内部：如下：</p>
<img src="/posts/cc605c90/image-20250111230712300.png" class="" title="image-20250111230712300">

<p>后面我们直接跟进后续的函数<code>rkprint</code>中：如下</p>
<img src="/posts/cc605c90/image-20250111231533290.png" class="" title="image-20250111231533290">

<p>里面有一个调用getb的函数我们可以跟进去看看它的逻辑：如下：</p>
<img src="/posts/cc605c90/image-20250111231716077.png" class="" title="image-20250111231716077">

<p>然后我们继续在<code>rkprint</code>函数下向下分析：如下：</p>
<p>传入这个赋值对象，压入要修改的内容<code>1F4h</code>,也就是<code>500</code></p>
<img src="/posts/cc605c90/image-20250111231942854.png" class="" title="image-20250111231942854">

<p>对值进行修改：修改为<code>500</code>对应<code>xx.seta(500);</code></p>
<img src="/posts/cc605c90/image-20250111232224810.png" class="" title="image-20250111232224810">

<p>回到main函数：它继续调用了一个函数，也就是<code>geta</code>函数：如下：</p>
<img src="/posts/cc605c90/image-20250111232756924.png" class="" title="image-20250111232756924">

<p>进入函数内部看看内容：如下：</p>
<img src="/posts/cc605c90/image-20250111232825514.png" class="" title="image-20250111232825514">

<p>只起到一个作用取出<code>a属性</code>的值,对应代码：<code>printf(&quot;%d&quot;, rk2.geta());</code>中的<code>rk2.geta()</code></p>
<h2 id="构造函数与析构函数识别分析：（第八天）"><a href="#构造函数与析构函数识别分析：（第八天）" class="headerlink" title="构造函数与析构函数识别分析：（第八天）"></a>构造函数与析构函数识别分析：（第八天）</h2><h4 id="构造函数："><a href="#构造函数：" class="headerlink" title="构造函数："></a>构造函数：</h4><h5 id="01-局部对象"><a href="#01-局部对象" class="headerlink" title="01.局部对象"></a>01.局部对象</h5><p>实验源代码如下：debug.cpp:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">rk</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">rk</span>();</span><br><span class="line">	~<span class="built_in">rk</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">rk::<span class="built_in">rk</span>()</span><br><span class="line">&#123;</span><br><span class="line">	age = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rk::~<span class="built_in">rk</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//局部对象 无参构造函数</span></span><br><span class="line">	rk mk;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ida反编译汇编代码如下：main函数：</p>
<img src="/posts/cc605c90/image-20250111234455848.png" class="" title="image-20250111234455848">

<p>构造函数内部对应代码内容如下：<code>age = 20;</code></p>
<img src="/posts/cc605c90/image-20250111234312854.png" class="" title="image-20250111234312854">





<h5 id="02-堆对象"><a href="#02-堆对象" class="headerlink" title="02.堆对象"></a>02.堆对象</h5><p>演示代码debug.cpp：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">rk</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">rk</span>();</span><br><span class="line">	~<span class="built_in">rk</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">rk::<span class="built_in">rk</span>()</span><br><span class="line">&#123;</span><br><span class="line">	age = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rk::~<span class="built_in">rk</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//堆对象</span></span><br><span class="line">	rk *p = <span class="keyword">new</span> <span class="built_in">rk</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拖入ida进入main函数位置，如下：</p>
<img src="/posts/cc605c90/image-20250112000749557.png" class="" title="image-20250112000749557">

<p>注释如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">push    4               ; Size,这里实际上就是需要new的尺寸</span><br><span class="line">call    j_??2@YAPAXI@Z  ; new函数</span><br><span class="line">add     esp, 4</span><br><span class="line">mov     [ebp+var_EC], eax ; 这个EC实际上就是new之后返回的一个地址</span><br><span class="line">;   try &#123;</span><br><span class="line">mov     [ebp+var_4], 0</span><br><span class="line">cmp     [ebp+var_EC], 0 ; 判断堆内存是否失败</span><br><span class="line">jz      short loc_455B9A</span><br><span class="line"></span><br><span class="line">mov     ecx, [ebp+var_EC] ; 传入的是对象的地址</span><br><span class="line">call    sub_450BAD      ; 构造函数，返回对象</span><br><span class="line">mov     [ebp+var_F4], eax ; 所以F4才是真正的对象</span><br><span class="line">jmp     short loc_455BA4</span><br><span class="line"></span><br><span class="line">loc_455B9A:             ; HANDLE = NULL</span><br><span class="line">mov     [ebp+var_F4], 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>进入构造函数内部，有如下内容：</p>
<img src="/posts/cc605c90/image-20250112001145396.png" class="" title="image-20250112001145396">

<p>完成对象的初始化内容之后，返回了一个对象。</p>
<h5 id="03-参数对象"><a href="#03-参数对象" class="headerlink" title="03.参数对象"></a>03.参数对象</h5><p>演示代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		name = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; obj) &#123;</span><br><span class="line">		<span class="type">int</span> len = <span class="built_in">strlen</span>(obj.name);</span><br><span class="line">		<span class="keyword">this</span>-&gt;name = <span class="keyword">new</span> <span class="type">char</span>[len + <span class="built_in">sizeof</span>(<span class="type">char</span>)];</span><br><span class="line">		<span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;name, obj.name);</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Person</span>() &#123;	</span><br><span class="line">		<span class="keyword">if</span> (name != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">delete</span>[] name;</span><br><span class="line">			name = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> len = <span class="built_in">strlen</span>(name);</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;name != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;name;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>-&gt;name = <span class="keyword">new</span> <span class="type">char</span>[len + <span class="built_in">sizeof</span>(<span class="type">char</span>)];</span><br><span class="line">		<span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;name, name);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">char</span> * name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;name:%s\n&quot;</span>, person.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">	Person person;</span><br><span class="line">	person.<span class="built_in">setName</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">	<span class="built_in">show</span>(person);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要是在show函数调用时，会进行一个拷贝构造：</p>
<img src="/posts/cc605c90/image-20250112012223619.png" class="" title="image-20250112012223619">

<p>在类的识别分析那里有一点笔记参考。</p>
<h4 id="析构函数："><a href="#析构函数：" class="headerlink" title="析构函数："></a>析构函数：</h4><h5 id="01-局部对象-1"><a href="#01-局部对象-1" class="headerlink" title="01.局部对象"></a>01.局部对象</h5><p>局部对象的析构过程和构造过程差不太多，执行位置不同而已，就不写了</p>
<h5 id="02-堆对象-1"><a href="#02-堆对象-1" class="headerlink" title="02.堆对象"></a>02.堆对象</h5><p>演示代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		age = <span class="number">20</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Person</span>() &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;~Person()\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">	Person *person = <span class="keyword">new</span> <span class="built_in">Person</span>();</span><br><span class="line">	person-&gt;age = <span class="number">21</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, person-&gt;age);</span><br><span class="line">	<span class="keyword">delete</span> person;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先<code>Person *person = new Person();</code>跟前面构造函数的堆对象构造所说内容一致。不过多赘述，如图：</p>
<img src="/posts/cc605c90/image-20250112005208454.png" class="" title="image-20250112005208454">

<p>接下来<code>person-&gt;age = 21;</code>，对应的是这一部分：如下：</p>
<img src="/posts/cc605c90/image-20250112005317216.png" class="" title="image-20250112005317216">

<p>对对象内部属性进行一个赋值的操作。</p>
<p>接下来我们来看看后续代码如下：</p>
<img src="/posts/cc605c90/image-20250112005558443.png" class="" title="image-20250112005558443">

<p>直接跳入delete函数内部继续分析如下：</p>
<p>主要执行了两个函数操作：</p>
<img src="/posts/cc605c90/image-20250112005709380.png" class="" title="image-20250112005709380">

<p>我们进入第一个中可以明显的发现其正是析构函数操作：如下：</p>
<img src="/posts/cc605c90/image-20250112005915219.png" class="" title="image-20250112005915219">

<p>我们再来看其第二个操作，如下：</p>
<p>delete释放对象内存</p>
<img src="/posts/cc605c90/image-20250112010004821.png" class="" title="image-20250112010004821">
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://Iconabc.github.io">icon</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://iconabc.github.io/posts/cc605c90.html">https://iconabc.github.io/posts/cc605c90.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://Iconabc.github.io" target="_blank">icon'Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%AD%A6%E5%99%A8%E5%8C%96%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/">武器化开发学习</a><a class="post-meta__tags" href="/tags/%E5%85%8D%E6%9D%80/">免杀</a></div><div class="post-share"><div class="social-share" data-image="/img/mbc.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/111fe729.html" title="04-Win32编程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">04-Win32编程</div></div><div class="info-2"><div class="info-item-1">Win32编程消息机制创建窗口的五个步骤：  注册窗口：RegisterClass&#x2F;RegisterClassEx  用户窗口：多种多样的，我们需要提前去注册，填充一个数据结构(窗口的清单) 系统窗口   创建窗口：CreateWindow&#x2F;CreateWindowEx  显示刷新窗口：ShowWindow&#x2F;UpdateWindow  消息循环：GetMessage&#x2F;PeekMessage  消息处理：LRESULT CALLBACK WinProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM...</div></div></div></a><a class="pagination-related" href="/posts/be4abe2b.html" title="02-x86_64架构汇编语言"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">02-x86_64架构汇编语言</div></div><div class="info-2"><div class="info-item-1">x86_64架构汇编语言汇编的概念与常用寄存器汇编语言（Assembly Language）是一种低级编程语言，直接与计算机硬件交互。它是机器语言的符号化表示，人类可以通过汇编语言编写程序，而计算机则通过汇编语言指令与硬件进行通信。汇编语言具有与特定计算机体系结构（如 x86、ARM 等）密切相关的语法和指令集。 主要特点：  低级语言：汇编语言离机器语言非常近，指令与机器代码几乎一一对应。 面向硬件：汇编语言能精确控制计算机硬件资源，如寄存器、内存、I&#x2F;O...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/111fe729.html" title="04-Win32编程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-12</div><div class="info-item-2">04-Win32编程</div></div><div class="info-2"><div class="info-item-1">Win32编程消息机制创建窗口的五个步骤：  注册窗口：RegisterClass&#x2F;RegisterClassEx  用户窗口：多种多样的，我们需要提前去注册，填充一个数据结构(窗口的清单) 系统窗口   创建窗口：CreateWindow&#x2F;CreateWindowEx  显示刷新窗口：ShowWindow&#x2F;UpdateWindow  消息循环：GetMessage&#x2F;PeekMessage  消息处理：LRESULT CALLBACK WinProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM...</div></div></div></a><a class="pagination-related" href="/posts/e11d0610.html" title="01-C++基础学习"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-22</div><div class="info-item-2">01-C++基础学习</div></div><div class="info-2"><div class="info-item-1">C&#x2F;C++基础学习环境搭建windows环境基础搭建：这个不介绍一路下一步就行 linux环境基础搭建： 我是搭建在Ubuntu上的： 1234567891011#首先更新一下源sudo apt update#安装一个文本编辑器sudo apt install vim#安装gccsudo apt install gcc#安装g++sudo apt install g++  让我来写第一个代码并将其编译看看是否已经下载完毕： Hello.c: 12345#include &lt;stdio.h&gt;int main()&#123;    printf(&quot;Hello World&quot;);    return 0;&#125;  编译.c文件成可执行文件： gcc -o hello hello.c   执行这个可执行文件：   因为我们的Ubuntu系统是64位的系统，所以他也默认给我们生成了64位的文件。 我们可以下载如下库这样就支持我们编译成32位的文件了 12sudo apt install gcc-multilibsudo apt install...</div></div></div></a><a class="pagination-related" href="/posts/be4abe2b.html" title="02-x86_64架构汇编语言"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-26</div><div class="info-item-2">02-x86_64架构汇编语言</div></div><div class="info-2"><div class="info-item-1">x86_64架构汇编语言汇编的概念与常用寄存器汇编语言（Assembly Language）是一种低级编程语言，直接与计算机硬件交互。它是机器语言的符号化表示，人类可以通过汇编语言编写程序，而计算机则通过汇编语言指令与硬件进行通信。汇编语言具有与特定计算机体系结构（如 x86、ARM 等）密切相关的语法和指令集。 主要特点：  低级语言：汇编语言离机器语言非常近，指令与机器代码几乎一一对应。 面向硬件：汇编语言能精确控制计算机硬件资源，如寄存器、内存、I&#x2F;O...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/mbc.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">icon</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">22</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">22</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Iconabc"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Iconabc/" target="_blank" title="Github"><i class="fab fa-github" style="color: #hdhfbb;"></i></a><a class="social-icon" href="mailto:2899345299@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #000000;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">up up</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-C-%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E6%8A%80%E6%9C%AF"><span class="toc-number">1.</span> <span class="toc-text">C&#x2F;C++软件逆向技术</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E5%AE%9A%E4%BD%8D%E7%9B%AE%E6%A0%87%E5%8A%9F%E8%83%BD%EF%BC%9A-%E7%AC%AC%E4%B8%80%E5%A4%A9"><span class="toc-number">1.1.</span> <span class="toc-text">分析定位目标功能：(第一天)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9A%E9%80%9A%E8%BF%87%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9D%A5%E6%89%BE"><span class="toc-number">1.1.1.</span> <span class="toc-text">第一种方式：通过字符串来找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9A%E6%A0%B9%E6%8D%AE%E4%B8%80%E5%AE%9A%E8%A7%84%E5%88%99%E6%9D%A5%E7%A1%AE%E5%AE%9A"><span class="toc-number">1.1.2.</span> <span class="toc-text">第二种方式：根据一定规则来确定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9A%E5%AF%BC%E5%85%A5%E8%A1%A8%E6%9F%A5%E7%9C%8B"><span class="toc-number">1.1.3.</span> <span class="toc-text">第三种方式：导入表查看</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E8%B0%83%E8%AF%95%E6%9F%A5%E8%AF%A2%E6%BC%94%E7%A4%BA%EF%BC%9A"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">静态调试查询演示：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E6%BC%94%E7%A4%BA%EF%BC%9A"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">动态调试演示：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95%E6%89%BE%E5%88%B0%E6%8C%87%E5%AE%9A%E5%8A%9F%E8%83%BD%EF%BC%9A"><span class="toc-number">1.1.4.</span> <span class="toc-text">利用方法找到指定功能：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%9E%90%EF%BC%9A"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">分析：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%EF%BC%9A"><span class="toc-number">1.1.4.1.1.</span> <span class="toc-text">扩展：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A%EF%BC%9A%EF%BC%88%E7%AC%AC%E4%BA%8C%E5%A4%A9%EF%BC%89"><span class="toc-number">1.2.</span> <span class="toc-text">函数调用约定：（第二天）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A%EF%BC%9A"><span class="toc-number">1.2.1.</span> <span class="toc-text">函数调用约定：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#cdecl"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">_cdecl:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#stdcall%EF%BC%9A"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">_stdcall：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fastcall%EF%BC%9A"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">_fastcall：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90%EF%BC%9A"><span class="toc-number">1.2.2.</span> <span class="toc-text">复杂结构分析：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#if-else%E8%AF%AD%E5%8F%A5%E8%AF%86%E5%88%AB%E5%88%86%E6%9E%90%EF%BC%9A%EF%BC%88%E7%AC%AC%E4%B8%89%E5%A4%A9%EF%BC%89"><span class="toc-number">1.3.</span> <span class="toc-text">if-else语句识别分析：（第三天）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#01-if"><span class="toc-number">1.3.1.</span> <span class="toc-text">01.if</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%9E%90%EF%BC%9Ax86-debug%E7%89%88%E6%9C%AC%E5%A6%82%E4%B8%8B"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">分析：x86 debug版本如下</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%9E%90%EF%BC%9Ax64-debug%E7%89%88%E6%9C%AC%E5%A6%82%E4%B8%8B"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">分析：x64 debug版本如下</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#02-if-else"><span class="toc-number">1.3.2.</span> <span class="toc-text">02.if-else</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%9E%90%EF%BC%9Ax86-debug%E7%89%88%E6%9C%AC%E5%A6%82%E4%B8%8B-1"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">分析：x86 debug版本如下</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#03-if-elseif-else"><span class="toc-number">1.3.3.</span> <span class="toc-text">03.if-elseif-else</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%9E%90%EF%BC%9Ax86-debug%E7%89%88%E6%9C%AC%E5%A6%82%E4%B8%8B-2"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">分析：x86 debug版本如下</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#04-%E5%A4%9A%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD"><span class="toc-number">1.3.4.</span> <span class="toc-text">04.多条件判断</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%9E%90%EF%BC%9Ax86-debug%E7%89%88%E6%9C%AC%E5%A6%82%E4%B8%8B-3"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">分析：x86 debug版本如下</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#switch%E8%AF%AD%E5%8F%A5%E8%AF%86%E5%88%AB%E5%88%86%E6%9E%90%EF%BC%9A%EF%BC%88%E7%AC%AC%E5%9B%9B%E5%A4%A9%EF%BC%89"><span class="toc-number">1.4.</span> <span class="toc-text">switch语句识别分析：（第四天）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#01-switch-3case"><span class="toc-number">1.4.1.</span> <span class="toc-text">01.switch-3case</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#02-switch-6case"><span class="toc-number">1.4.2.</span> <span class="toc-text">02.switch-6case</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#03-switch-6case%E7%BC%BA%E9%A1%B9"><span class="toc-number">1.4.3.</span> <span class="toc-text">03.switch-6case缺项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#04-switch-6case%E5%8D%95%E9%A1%B9%E4%B8%8D%E8%BF%9E%E7%BB%AD"><span class="toc-number">1.4.4.</span> <span class="toc-text">04.switch-6case单项不连续</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#05-switch-6case%E5%A4%9A%E7%BA%BF%E8%A1%A8"><span class="toc-number">1.4.5.</span> <span class="toc-text">05.switch-6case多线表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#06-switch-6case%E6%97%A0%E7%BA%BF%E8%A1%A8%E6%97%A0break"><span class="toc-number">1.4.6.</span> <span class="toc-text">06.switch-6case无线表无break</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#01-while%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.4.7.</span> <span class="toc-text">01.while循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#02-for%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.4.8.</span> <span class="toc-text">02.for循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#03-dowhile%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.4.9.</span> <span class="toc-text">03.dowhile循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#04-%E5%BE%AA%E7%8E%AF%E5%B5%8C%E5%A5%97"><span class="toc-number">1.4.10.</span> <span class="toc-text">04.循环嵌套</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88%E8%AF%86%E5%88%AB%E5%88%86%E6%9E%90%EF%BC%9A-%E7%AC%AC%E5%85%AD%E5%A4%A9"><span class="toc-number">1.5.</span> <span class="toc-text">数组与指针识别分析：(第六天)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#01-%E5%87%BD%E6%95%B0%E5%86%85%E7%9A%84%E6%95%B0%E7%BB%84"><span class="toc-number">1.5.1.</span> <span class="toc-text">01.函数内的数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%B8%8E%E5%A4%9A%E4%B8%AA%E5%90%8C%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">数组与多个同类型变量的区别：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%EF%BC%9A"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">字符数组：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#02-%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0"><span class="toc-number">1.5.2.</span> <span class="toc-text">02.数组作为参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#x86-debug%EF%BC%9A%E5%88%86%E6%9E%90"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">x86 debug：分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#x64-debug%EF%BC%9A%E5%88%86%E6%9E%90"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">x64 debug：分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#03-%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BA%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">1.5.3.</span> <span class="toc-text">03.数组作为返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#04-%E4%B8%8B%E6%A0%87%E5%92%8C%E6%8C%87%E9%92%88%E5%AF%BB%E5%9D%80"><span class="toc-number">1.5.4.</span> <span class="toc-text">04.下标和指针寻址</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%AF%BB%E5%9D%80%EF%BC%9A"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">指针寻址：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8B%E6%A0%87%E5%AF%BB%E5%9D%80%EF%BC%9A"><span class="toc-number">1.5.4.2.</span> <span class="toc-text">下标寻址：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#05-%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">1.5.5.</span> <span class="toc-text">05.多维数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-number">1.5.5.1.</span> <span class="toc-text">二维数组的寻址方式：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%8C%E4%BC%98%E5%85%88%E5%AD%98%E5%82%A8%EF%BC%88Row-major-order%EF%BC%89"><span class="toc-number">1.5.5.2.</span> <span class="toc-text">行优先存储（Row-major order）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#06-%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84"><span class="toc-number">1.5.6.</span> <span class="toc-text">06.指针数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#07-%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88"><span class="toc-number">1.5.7.</span> <span class="toc-text">07.数组指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#08-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">1.5.8.</span> <span class="toc-text">08.函数指针</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AF%86%E5%88%AB%E5%88%86%E6%9E%90%EF%BC%9A-%E7%AC%AC%E4%B8%83%E5%A4%A9"><span class="toc-number">1.6.</span> <span class="toc-text">类与对象的识别分析：(第七天)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#01-%E5%AF%B9%E8%B1%A1%E5%B8%83%E5%B1%80"><span class="toc-number">1.6.1.</span> <span class="toc-text">01.对象布局</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AA%E7%BB%A7%E6%89%BF%E5%AF%B9%E8%B1%A1%E5%B8%83%E5%B1%80"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">未继承对象布局</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E5%90%8E%E5%AF%B9%E8%B1%A1%E5%B8%83%E5%B1%80"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">继承后对象布局</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%EF%BC%9A"><span class="toc-number">1.6.1.2.1.</span> <span class="toc-text">解释：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-number">1.6.1.2.2.</span> <span class="toc-text">虚函数表的工作原理：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#02-this%E6%8C%87%E9%92%88"><span class="toc-number">1.6.2.</span> <span class="toc-text">02.this指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#03-%E4%BD%BF%E7%94%A8%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%8F%8A%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">1.6.3.</span> <span class="toc-text">03.使用对象作为函数参数及返回值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E8%AF%86%E5%88%AB%E5%88%86%E6%9E%90%EF%BC%9A%EF%BC%88%E7%AC%AC%E5%85%AB%E5%A4%A9%EF%BC%89"><span class="toc-number">1.7.</span> <span class="toc-text">构造函数与析构函数识别分析：（第八天）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-number">1.7.0.1.</span> <span class="toc-text">构造函数：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#01-%E5%B1%80%E9%83%A8%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.7.0.1.1.</span> <span class="toc-text">01.局部对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#02-%E5%A0%86%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.7.0.1.2.</span> <span class="toc-text">02.堆对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#03-%E5%8F%82%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.7.0.1.3.</span> <span class="toc-text">03.参数对象</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-number">1.7.0.2.</span> <span class="toc-text">析构函数：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#01-%E5%B1%80%E9%83%A8%E5%AF%B9%E8%B1%A1-1"><span class="toc-number">1.7.0.2.1.</span> <span class="toc-text">01.局部对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#02-%E5%A0%86%E5%AF%B9%E8%B1%A1-1"><span class="toc-number">1.7.0.2.2.</span> <span class="toc-text">02.堆对象</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/111fe729.html" title="04-Win32编程">04-Win32编程</a><time datetime="2025-01-12T07:35:28.000Z" title="发表于 2025-01-12 15:35:28">2025-01-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/cc605c90.html" title="03-C/C++软件逆向技术">03-C/C++软件逆向技术</a><time datetime="2025-01-11T13:52:21.000Z" title="发表于 2025-01-11 21:52:21">2025-01-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/be4abe2b.html" title="02-x86_64架构汇编语言">02-x86_64架构汇编语言</a><time datetime="2024-12-26T08:44:51.000Z" title="发表于 2024-12-26 16:44:51">2024-12-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/e11d0610.html" title="01-C++基础学习">01-C++基础学习</a><time datetime="2024-12-22T01:59:42.000Z" title="发表于 2024-12-22 09:59:42">2024-12-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/ad068c24.html" title="多级代理工具">多级代理工具</a><time datetime="2024-12-18T12:33:28.000Z" title="发表于 2024-12-18 20:33:28">2024-12-18</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/shuai.jpg);"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2025 By icon</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><a href="/">icon</a> is striving to become stronger!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo

  const disqusReset = conf => {
    window.DISQUS && window.DISQUS.reset({
      reload: true,
      config: conf
    })
  }

  const loadDisqus = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyDisqus = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    window.disqus_identifier = isShuoshuo ? path : '/posts/cc605c90.html'
    window.disqus_url = isShuoshuo ? location.origin + path : 'https://iconabc.github.io/posts/cc605c90.html'

    const disqus_config = function () {
      this.page.url = disqus_url
      this.page.identifier = disqus_identifier
      this.page.title = '03-C/C++软件逆向技术'
    }

    if (window.DISQUS) disqusReset(disqus_config)
    else {
      const script = document.createElement('script')
      script.src = 'https://.disqus.com/embed.js'
      script.setAttribute('data-timestamp', +new Date())
      document.head.appendChild(script)
    }

    btf.addGlobalFn('themeChange', () => disqusReset(disqus_config), 'disqus')
  }

  const getCount = async() => {
    try {
      const eleGroup = document.querySelector('#post-meta .disqus-comment-count')
      if (!eleGroup) return
      const cleanedLinks = eleGroup.href.replace(/#post-comment$/, '')

      const res = await fetch(`https://disqus.com/api/3.0/threads/set.json?forum=&api_key=&thread:link=${cleanedLinks}`,{
        method: 'GET'
      })
      const result = await res.json()

      const count = result.response.length ? result.response[0].posts : 0
      eleGroup.textContent = count
    } catch (err) {
      console.error(err)
    }
  }

  if (isShuoshuo) {
    'Disqus' === 'Disqus'
      ? window.shuoshuoComment = { loadComment: loadDisqus }
      : window.loadOtherComment = loadDisqus
    return
  }

  if ('Disqus' === 'Disqus' || !false) {
    if (false) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
    else {
      loadDisqus()
      
    }
  } else {
    window.loadOtherComment = loadDisqus
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>