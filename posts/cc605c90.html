<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>03-C/C++软件逆向技术 | icon'Blog</title><meta name="author" content="icon"><meta name="copyright" content="icon"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="C&#x2F;C++软件逆向技术分析定位目标功能：设置一下Debug：如下   设置一下Release：如下   对如下代码生成不同版本的exe: 123456#include &lt;stdio.h&gt;int main() &#123;	printf(&quot;hello Re&quot;);	return 0;&#125;  将debug版本的直接脱入ida：   拖入成功后。 它会给你">
<meta property="og:type" content="article">
<meta property="og:title" content="03-C&#x2F;C++软件逆向技术">
<meta property="og:url" content="https://iconabc.github.io/posts/cc605c90.html">
<meta property="og:site_name" content="icon&#39;Blog">
<meta property="og:description" content="C&#x2F;C++软件逆向技术分析定位目标功能：设置一下Debug：如下   设置一下Release：如下   对如下代码生成不同版本的exe: 123456#include &lt;stdio.h&gt;int main() &#123;	printf(&quot;hello Re&quot;);	return 0;&#125;  将debug版本的直接脱入ida：   拖入成功后。 它会给你">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://iconabc.github.io/img/mbc.jpg">
<meta property="article:published_time" content="2024-12-28T05:19:21.000Z">
<meta property="article:modified_time" content="2024-12-28T17:16:03.276Z">
<meta property="article:author" content="icon">
<meta property="article:tag" content="武器化开发学习">
<meta property="article:tag" content="免杀">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://iconabc.github.io/img/mbc.jpg"><link rel="shortcut icon" href="/img/shasha.png"><link rel="canonical" href="https://iconabc.github.io/posts/cc605c90.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: icon","link":"链接: ","source":"来源: icon'Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '03-C/C++软件逆向技术',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/mbc.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">21</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> about</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/shuai.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">icon'Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">03-C/C++软件逆向技术</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> about</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">03-C/C++软件逆向技术</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-12-28T05:19:21.000Z" title="发表于 2024-12-28 13:19:21">2024-12-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-12-28T17:16:03.276Z" title="更新于 2024-12-29 01:16:03">2024-12-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C-C-%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E6%8A%80%E6%9C%AF/">C/C++软件逆向技术</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">2.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>8分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="C-C-软件逆向技术"><a href="#C-C-软件逆向技术" class="headerlink" title="C&#x2F;C++软件逆向技术"></a>C&#x2F;C++软件逆向技术</h1><h2 id="分析定位目标功能："><a href="#分析定位目标功能：" class="headerlink" title="分析定位目标功能："></a>分析定位目标功能：</h2><p>设置一下Debug：如下</p>
<img src="/posts/undefined/image-20241228141831808.png" class="" title="image-20241228141831808">

<p>设置一下Release：如下</p>
<img src="/posts/undefined/image-20241228141932693.png" class="" title="image-20241228141932693">

<p>对如下代码生成不同版本的exe:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;hello Re&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将debug版本的直接脱入ida：</p>
<img src="/posts/undefined/image-20241228160642858.png" class="" title="image-20241228160642858">

<p>拖入成功后。</p>
<p>它会给你三种选项，如下：</p>
<img src="/posts/undefined/image-20241228161437585.png" class="" title="image-20241228161437585">

<p>让你选择以某一种方式对他进行解析：</p>
<p>第一种方式：pe文件的方式对你的文件进行解析</p>
<p>第二种方式：是利用dos的形式对它进行解析</p>
<p>第三种方式：是利用二进制文本的方式对它进行解析，想怎么解就怎么解</p>
<p>这里我们已经知道是pe的可以直接选择第一种。</p>
<p>下面这个是可以简单选择一些架构的：我们选择metapoc</p>
<img src="/posts/undefined/image-20241228161823929.png" class="" title="image-20241228161823929">

<p>加载完毕后来到这个：这个页面：</p>
<img src="/posts/undefined/image-20241228162701775.png" class="" title="image-20241228162701775">

<p>我们可以通过如下方法来定位一手主函数main：</p>
<h3 id="第一种方式：通过字符串来找"><a href="#第一种方式：通过字符串来找" class="headerlink" title="第一种方式：通过字符串来找"></a>第一种方式：通过字符串来找</h3><img src="/posts/undefined/image-20241228163410444.png" class="" title="image-20241228163410444">

<p>我们直接ctrl+f进行一下搜索：</p>
<img src="/posts/undefined/image-20241228163618117.png" class="" title="image-20241228163618117">

<p>然后双击点进去：</p>
<img src="/posts/undefined/image-20241228163719641.png" class="" title="image-20241228163719641">

<p>会发现有个名字这个是ida自动给你取的。</p>
<p>然后点击这个名字以后按下<code>ctrl+x</code>它会弹出一个交叉引用：(这里我是用的本机的ida7.7才弹出的)</p>
<img src="/posts/undefined/image-20241228163939324.png" class="" title="image-20241228163939324">

<p>这个所谓的<code>交叉引用</code>呢？就是你的这个字符串在全局内被调用了多少次，在哪被调用的，观察上图我们可以发现上图只有被调用了一次点击以后，选择ok。</p>
<p>ida9中可以右键点击：如下选择也可弹出：</p>
<img src="/posts/undefined/image-20241228164138212.png" class="" title="image-20241228164138212">

<p>观察上图我们可以发现上图只有被调用了一次点击以后，选择ok。</p>
<p>ok以后就跳到如下界面了，如下界面也就是我们的main函数：</p>
<img src="/posts/undefined/image-20241228164437847.png" class="" title="image-20241228164437847">

<p>接下来呢我们可以按空格把他切换到文本模式，也可以再按空格切换回流程图模式，如下：</p>
<img src="/posts/undefined/image-20241228164532559.png" class="" title="image-20241228164532559">



<p>也可以直接按F5把他转换成伪代码的形式：如下</p>
<img src="/posts/undefined/image-20241228164922054.png" class="" title="image-20241228164922054">

<h3 id="第二种方式：根据一定规则来确定"><a href="#第二种方式：根据一定规则来确定" class="headerlink" title="第二种方式：根据一定规则来确定"></a>第二种方式：根据一定规则来确定</h3><p>假设我们已经知道了其对应的生成规则：然后重新生成一个demo.。</p>
<p>然后一层一层网上找，尝试了解他的main函数是如何找到的</p>
<p>我们直接右键，选择<code>交叉引用</code>，找它的上一级调用：如下：</p>
<img src="/posts/undefined/image-20241228170023653.png" class="" title="image-20241228170023653">

<p>有一个<code> jmp main</code>，我们跳过去:如下</p>
<img src="/posts/undefined/image-20241228170216772.png" class="" title="image-20241228170216772">

<p>这层是只有一个 <code>jmp _main</code>跳过去的：</p>
<p><strong>确定第1层：</strong><code>jmp _main</code></p>
<hr>

<p>接下来我们直接：右键查看上一层：如下</p>
<img src="/posts/undefined/image-20241228170444961.png" class="" title="image-20241228170444961">

<p>我们会发现它传入了3个参数：</p>
<img src="/posts/undefined/image-20241228170554453.png" class="" title="image-20241228170554453">

<p>然后我们观察会发现他是这3个<code>call</code>里面的最后一个<code>call</code></p>
<p>于是乎我们可以记录如下特征：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov     ecx, [eax]</span><br><span class="line">push    ecx             ; argc</span><br><span class="line">call    _main_0</span><br></pre></td></tr></table></figure>

<p>也可以记录<strong>进最后一个call</strong></p>
<p><strong>确定第2层：上面记录的就是第二层的特征</strong></p>
<hr>

<p>接下来我们继续进入上一层：</p>
<p>还是右键进入同上一样的操作：如下</p>
<img src="/posts/undefined/image-20241228171049211.png" class="" title="image-20241228171049211">

<p>我们可以将这几行作为一个特征：如下</p>
<img src="/posts/undefined/image-20241228171211010.png" class="" title="image-20241228171211010">

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">经过整理：如下所示即为这一层的特征</span><br><span class="line">movzx</span><br><span class="line">test</span><br><span class="line">jz</span><br><span class="line">mov</span><br><span class="line">mov</span><br><span class="line">push</span><br><span class="line">call</span><br><span class="line">add</span><br><span class="line">call</span><br></pre></td></tr></table></figure>

<p><strong>确定第3层</strong>：如上特征</p>
<hr>

<p>接下来我们继续往上找，找到这里的函数头：</p>
<img src="/posts/undefined/image-20241228171822419.png" class="" title="image-20241228171822419">

<p>找到其函数头然后进入上一层：如下</p>
<img src="/posts/undefined/image-20241228172202914.png" class="" title="image-20241228172202914">

<p>发现如下特征：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">call</span><br><span class="line">call</span><br><span class="line">然后我们可以记录一下特征是第二个call</span><br></pre></td></tr></table></figure>

<p><strong>确定第4层</strong>：特征如上</p>
<hr>

<p>接下来我们继续向上找看看还有没有上一层：</p>
<p>找到函数头，然后进入上一层：如下：</p>
<img src="/posts/undefined/image-20241228172439028.png" class="" title="image-20241228172439028">

<p>进入后如下</p>
<img src="/posts/undefined/image-20241228172513294.png" class="" title="image-20241228172513294">

<p>这一层就1个<code>call</code>:</p>
<p>直接记录就对了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call</span><br></pre></td></tr></table></figure>

<p><strong>确定第5层</strong>：如上。</p>
<hr>

<p>再继续向上一层：</p>
<img src="/posts/undefined/image-20241228172723292.png" class="" title="image-20241228172723292">

<p>这一层呢是一个jmp，并且jmp这一层呢已经到start了，说明已经到头了</p>
<p>特征：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp</span><br></pre></td></tr></table></figure>

<p><strong>确定第6层</strong></p>
<hr>

<p><strong>根据上述流程我们倒着把他记录了下来。</strong></p>
<p>接下来我们根据上述流程正着进这个main函数。</p>
<p>利用<strong>x64dbg</strong>来进行一下动态调试：</p>
<p>一打开我们就来到了：ntdll.dll模块下，如下：</p>
<img src="/posts/undefined/image-20241228185007916.png" class="" title="image-20241228185007916">

<p>直接F9跳入到我自己的程序临空：如下：</p>
<img src="/posts/undefined/image-20241228185158107.png" class="" title="image-20241228185158107">

<p>进入以后我就可以掏出我自己的规则：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">X86 Debug：</span><br><span class="line">1.jmp main</span><br><span class="line">2.进入最后一个call</span><br><span class="line">3.</span><br><span class="line">movzx</span><br><span class="line">test</span><br><span class="line">jz</span><br><span class="line">mov</span><br><span class="line">mov</span><br><span class="line">push</span><br><span class="line">call</span><br><span class="line">add</span><br><span class="line">call</span><br><span class="line">4.第二个call</span><br><span class="line">5.call</span><br><span class="line">6.jmp</span><br><span class="line"></span><br><span class="line">倒过来就是正向的进入main规则了</span><br></pre></td></tr></table></figure>

<p>直接F8<code> jmp</code>进入 入口点：如下：</p>
<img src="/posts/undefined/image-20241228185730275.png" class="" title="image-20241228185730275">

<p>进入以后这里就一个call我们直接：<strong>F8下一步到call上以后直接F7跟进这个call</strong></p>
<img src="/posts/undefined/image-20241228185833944.png" class="" title="image-20241228185833944">

<p>跟进以后可以看到如下内容：如下图：</p>
<img src="/posts/undefined/image-20241228185955728.png" class="" title="image-20241228185955728">

<p><strong>根据规则我们需要进入第二个call</strong>：F8 F8 F7跟进：如下图：</p>
<img src="/posts/undefined/image-20241228190213587.png" class="" title="image-20241228190213587">

<p>然后根据下一个规则：</p>
<p>找如下特征：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">3.</span><br><span class="line">movzx</span><br><span class="line">test</span><br><span class="line">jz</span><br><span class="line">mov</span><br><span class="line">mov</span><br><span class="line">push</span><br><span class="line">call</span><br><span class="line">add</span><br><span class="line">call</span><br></pre></td></tr></table></figure>

<p>找到如下特征以后：F2下个断点：如下:</p>
<img src="/posts/undefined/image-20241228190718677.png" class="" title="image-20241228190718677">

<p>然后F9运行到此：然后F2取消断点：如下：</p>
<img src="/posts/undefined/image-20241228190848258.png" class="" title="image-20241228190848258">

<p>然后继续F7跟进：如下：</p>
<img src="/posts/undefined/image-20241228191335207.png" class="" title="image-20241228191335207">

<p>然后继续根据规则：进入最后一个call:</p>
<p>F2下个断点然后F9运行到这，以后F2取消断点：如下：</p>
<img src="/posts/undefined/image-20241228191511004.png" class="" title="image-20241228191511004">

<p>F7跟进去：如下：</p>
<img src="/posts/undefined/image-20241228191605680.png" class="" title="image-20241228191605680">

<p>然后我们直接F8jmp：可以成功看到我们的main函数：如下：</p>
<img src="/posts/undefined/image-20241228191709022.png" class="" title="image-20241228191709022">

<img src="/posts/undefined/image-20241228191843017.png" class="" title="image-20241228191843017">

<p>上述的就是X86 Debug的一个根据结果倒过来找路线的全过程。</p>
<p>然后可以自己调试一下前面生成的<code>x64 debug</code></p>
<p>过程我忽略一下：直接找到如下规则：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">x64 debug：</span><br><span class="line"></span><br><span class="line">第一层：</span><br><span class="line">main_0          proc near               </span><br><span class="line">jmp     main</span><br><span class="line">main_0          endp</span><br><span class="line"></span><br><span class="line">第二层：</span><br><span class="line">最后一个call</span><br><span class="line"></span><br><span class="line">第三层：</span><br><span class="line">call    j___scrt_is_nonwritable_in_current_image</span><br><span class="line">movzx   eax, al</span><br><span class="line">test    eax, eax</span><br><span class="line">jz      short loc_140067DE9</span><br><span class="line">mov     rax, [rsp+68h+var_30]</span><br><span class="line">mov     rcx, [rax]      ; Callback</span><br><span class="line">call    j__register_thread_local_exe_atexit_callback</span><br><span class="line"></span><br><span class="line">call    ?invoke_main@@YAHXZ ; invoke_main(void)</span><br><span class="line">mov     [rsp+68h+Code], eax</span><br><span class="line">call    j___scrt_is_managed_app</span><br><span class="line"></span><br><span class="line">倒数第二个call</span><br><span class="line"></span><br><span class="line">第四层：</span><br><span class="line">第二个call</span><br><span class="line"></span><br><span class="line">第五层：</span><br><span class="line">只有一个call直接进</span><br><span class="line"></span><br><span class="line">第六层：</span><br><span class="line">jmp     mainCRTStartup</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">x86 release：</span><br><span class="line"></span><br><span class="line">第一层：</span><br><span class="line">push    eax             ; envp</span><br><span class="line">push    edi             ; argv</span><br><span class="line">push    dword ptr [esi] ; argc</span><br><span class="line">call    _main</span><br><span class="line"></span><br><span class="line">第二层：</span><br><span class="line">call    ___security_init_cookie</span><br><span class="line">jmp     __scrt_common_main_seh</span><br><span class="line">直接jmp</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>选择高亮模式进行调试是个看着会舒服很多：</p>
<img src="/posts/undefined/image-20241228200450777.png" class="" title="image-20241228200450777">

<h3 id="第三种方式：导入表查看"><a href="#第三种方式：导入表查看" class="headerlink" title="第三种方式：导入表查看"></a>第三种方式：导入表查看</h3><p>首先生成如下代码exe</p>
<p><code>Release x86</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//弹窗</span></span><br><span class="line">	<span class="built_in">MessageBoxA</span>(<span class="literal">NULL</span>,<span class="string">&quot;Msg&quot;</span>,<span class="string">&quot;rkvir&quot;</span>, MB_OK);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="静态调试查询演示："><a href="#静态调试查询演示：" class="headerlink" title="静态调试查询演示："></a>静态调试查询演示：</h4><p>拖入IDA9.0</p>
<p>首先，它已经直接识别出main函数：如下：</p>
<img src="/posts/undefined/image-20241228213543861.png" class="" title="image-20241228213543861">

<p><strong>如果没有识别出来呢？</strong></p>
<p>我们可以去导入表内看看：如下：用到的api都在下显示了</p>
<img src="/posts/undefined/image-20241228213708436.png" class="" title="image-20241228213708436">

<p>我们ctrl+F进行一下搜索：如下：</p>
<img src="/posts/undefined/image-20241228213835358.png" class="" title="image-20241228213835358">

<p>双击点击进入：如下：</p>
<img src="/posts/undefined/image-20241228214009926.png" class="" title="image-20241228214009926">

<p>我们会看到他进行了一个跨模块的引用：</p>
<p><strong><code>@16</code>是什么呢？</strong></p>
<p>就是它的参数：32位加4字节一个</p>
<p>MessageBoxA四个参数</p>
<p><strong>前面粉色的代表什么呢？</strong></p>
<p>粉色就代表着它是一个跨模块的调用，它是在其他的模块里拥有的这么一个东西</p>
<p>上方<code>int (__stdcall *MessageBoxA)</code>还说明其返回值，以及调用约定</p>
<p>接下来我们直接对其进行一个<code>右键+交叉引用</code>的形式来找他的这个位置，如下：</p>
<img src="/posts/undefined/image-20241228214748691.png" class="" title="image-20241228214748691">

<p>发现两个位置都在调用，其实两个位置都一样，如下：</p>
<img src="/posts/undefined/image-20241228214918232.png" class="" title="image-20241228214918232">

<p>会发现我们已经成功找到main函数了。</p>
<h4 id="动态调试演示："><a href="#动态调试演示：" class="headerlink" title="动态调试演示："></a>动态调试演示：</h4><p>利用x64dbg打开程序，右键——&gt;搜索——&gt;所有模块——&gt;跨模块调用如下：</p>
<img src="/posts/undefined/image-20241228215448207.png" class="" title="image-20241228215448207">

<img src="/posts/undefined/image-20241228215554752.png" class="" title="image-20241228215554752">

<p>在左下角的搜索框内搜索：MessageBoxA：如下：</p>
<img src="/posts/undefined/image-20241228215645332.png" class="" title="image-20241228215645332">

<p>然后双击直接进入：</p>
<img src="/posts/undefined/image-20241228215721599.png" class="" title="image-20241228215721599">

<h3 id="利用方法找到指定功能："><a href="#利用方法找到指定功能：" class="headerlink" title="利用方法找到指定功能："></a>利用方法找到指定功能：</h3><p>上述的这些方法也不见得非得用来找main函数，也可以用来找一些指定的功能。</p>
<p>比方说我来写这样一个程序：（选择MFC程序）</p>
<p>创建新项目：如下</p>
<img src="/posts/undefined/image-20241228215952185.png" class="" title="image-20241228215952185">

<p>然后直接生成这个文件点击<code>资源文件</code>选择<code>MFCApplication1.rc</code>进入如下界面：</p>
<img src="/posts/undefined/image-20241228234024080.png" class="" title="image-20241228234024080">

<p>并且修改成上图模样，然后右键<code>button1</code>属性</p>
<p>修改如下：</p>
<img src="/posts/undefined/image-20241228234308485.png" class="" title="image-20241228234308485">

<p>然后双击<code>Msg</code>：如下：</p>
<img src="/posts/undefined/image-20241228234503803.png" class="" title="image-20241228234503803">

<p>跳转到此处：如下：</p>
<img src="/posts/undefined/image-20241228234544180.png" class="" title="image-20241228234544180">

<p>并在其中写入弹窗代码：如下：</p>
<img src="/posts/undefined/image-20241228234725822.png" class="" title="image-20241228234725822">

<p>完成以后配置一下项目属性：设置成如下：</p>
<img src="/posts/undefined/image-20241228234902369.png" class="" title="image-20241228234902369">

<p>完成以后我们直接**<code>右键</code>——&gt;<code>重新生成</code>**生成一个exe文件。如下：</p>
<img src="/posts/undefined/image-20241228235114189.png" class="" title="image-20241228235114189">

<p>其能达到这么一个效果：如下：</p>
<img src="/posts/undefined/image-20241229001646272.png" class="" title="image-20241229001646272">

<h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h4><p>我们该如何找到如下功能点呢？</p>
<img src="/posts/undefined/image-20241229000140394.png" class="" title="image-20241229000140394">

<p>拖入ida以后：</p>
<p>我们可以看看其字符串，也可以看看其导入表。</p>
<p>这里我直接对导入表进行一个翻看然后<code>ctrl+F</code>搜索<code>MessageBoxA</code>然后找到其函数以后再对其进行<code>右键查询交叉引用</code>找到其调用然后对函数进行一个重命名：如下：</p>
<img src="/posts/undefined/image-20241229000422227.png" class="" title="image-20241229000422227">

<p>接下来对其再进行一个交叉引用：如下：</p>
<img src="/posts/undefined/image-20241229000533596.png" class="" title="image-20241229000533596">

<p>跳转过来以后我们继续对其进行交叉引用继续往上追：如下：</p>
<img src="/posts/undefined/image-20241229000641348.png" class="" title="image-20241229000641348">

<p>上层结果如下：</p>
<img src="/posts/undefined/image-20241229001042381.png" class="" title="image-20241229001042381">

<hr>

<p><strong>接下来我们给原本的这个程序加点东西来分析：</strong></p>
<img src="/posts/undefined/image-20241229001329439.png" class="" title="image-20241229001329439">

<p>然后给其添加变量，如下：</p>
<img src="/posts/undefined/image-20241229001403784.png" class="" title="image-20241229001403784">

<img src="/posts/undefined/image-20241229001454624.png" class="" title="image-20241229001454624">

<p>这样设置完两个变量之后我们双击就不弹窗，我们让其做一个对比比较：</p>
<p>功能：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCApplication1Dlg::OnBnClickedButton1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">UpdateData</span>(TRUE);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (m_IntA == m_IntB)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">MessageBoxA</span>(<span class="literal">NULL</span>, <span class="string">&quot;Success!&quot;</span>, <span class="string">&quot;Msg&quot;</span>, MB_OK);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">MessageBoxA</span>(<span class="literal">NULL</span>, <span class="string">&quot;Faild!&quot;</span>, <span class="string">&quot;Msg&quot;</span>, MB_OK);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UpdateData</span>(FALSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如下：</p>
<img src="/posts/undefined/image-20241229003553590.png" class="" title="image-20241229003553590">

<p>然后<strong>重新生成</strong>。</p>
<p>先将其拖入ida中加载，有一些慢，那我们进行一下动态调试：如下：</p>
<img src="/posts/undefined/image-20241229004024866.png" class="" title="image-20241229004024866">

<p>现在我们要做的就是要找出他的对比：</p>
<p>可以看到有如下效果：</p>
<img src="/posts/undefined/image-20241229004139732.png" class="" title="image-20241229004139732">

<img src="/posts/undefined/image-20241229004158469.png" class="" title="image-20241229004158469">

<p>先将其运行起来：如下：</p>
<img src="/posts/undefined/image-20241229004626350.png" class="" title="image-20241229004626350">

<p>那么现在呢我们就是要找出他其中的对比。</p>
<p>我们直接**<code>右键搜索</code>——&gt;<code>跨模块调用</code>**</p>
<img src="/posts/undefined/image-20241229004818255.png" class="" title="image-20241229004818255">

<p><strong>从这里找到他的弹窗的那个东西！</strong>！！</p>
<p>我们找他是有一定依据的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">弹窗</span><br><span class="line">MessageBoxA/W</span><br><span class="line">afxMessageBox</span><br><span class="line">CreateWindow</span><br></pre></td></tr></table></figure>

<p>我们可以追踪到他的根源，我们可以做出如下操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bp MessageBoxA 下断点（软件断点）</span><br></pre></td></tr></table></figure>

<img src="/posts/undefined/image-20241229005318707.png" class="" title="image-20241229005318707">

<p>然后回车，这样他就根据我们的api给我们下了一个断点。如下：</p>
<img src="/posts/undefined/image-20241229005428915.png" class="" title="image-20241229005428915">

<p>又或者我们可以来查看跨模块调用以后直接搜索这个函数<code>MessageBoxA</code>,如下：</p>
<img src="/posts/undefined/image-20241229005650418.png" class="" title="image-20241229005650418">

<p>然后双击进入，再点击如下：</p>
<img src="/posts/undefined/image-20241229005936043.png" class="" title="image-20241229005936043">

<p>随便点一个跟进去，无论是不是你都可以下个断点，如下：</p>
<img src="/posts/undefined/image-20241229010043713.png" class="" title="image-20241229010043713">

<p>不论是上面的那种方式我们都是可以找到这个位置的。</p>
<p>接下来让其运行起来我们就可以进行调试了，然后点击按钮：如下：</p>
<img src="/posts/undefined/image-20241229010952692.png" class="" title="image-20241229010952692">

<p>接下来我们还要找一个向上的堆栈：他停在上面的断点后，我们点击调用堆栈如下：</p>
<p>调用堆栈就你来源于哪，就是你上一级的调用和上上一级的调用都是来源于哪。</p>
<img src="/posts/undefined/image-20241229011354436.png" class="" title="image-20241229011354436">

<p>41：30</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://Iconabc.github.io">icon</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://iconabc.github.io/posts/cc605c90.html">https://iconabc.github.io/posts/cc605c90.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://Iconabc.github.io" target="_blank">icon'Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%AD%A6%E5%99%A8%E5%8C%96%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/">武器化开发学习</a><a class="post-meta__tags" href="/tags/%E5%85%8D%E6%9D%80/">免杀</a></div><div class="post-share"><div class="social-share" data-image="/img/mbc.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/posts/be4abe2b.html" title="02-x86_64架构汇编语言"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">02-x86_64架构汇编语言</div></div><div class="info-2"><div class="info-item-1">x86_64架构汇编语言汇编的概念与常用寄存器汇编语言（Assembly Language）是一种低级编程语言，直接与计算机硬件交互。它是机器语言的符号化表示，人类可以通过汇编语言编写程序，而计算机则通过汇编语言指令与硬件进行通信。汇编语言具有与特定计算机体系结构（如 x86、ARM 等）密切相关的语法和指令集。 主要特点：  低级语言：汇编语言离机器语言非常近，指令与机器代码几乎一一对应。 面向硬件：汇编语言能精确控制计算机硬件资源，如寄存器、内存、I&#x2F;O...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/e11d0610.html" title="01-C++基础学习"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-22</div><div class="info-item-2">01-C++基础学习</div></div><div class="info-2"><div class="info-item-1">C&#x2F;C++基础学习环境搭建windows环境基础搭建：这个不介绍一路下一步就行 linux环境基础搭建： 我是搭建在Ubuntu上的： 1234567891011#首先更新一下源sudo apt update#安装一个文本编辑器sudo apt install vim#安装gccsudo apt install gcc#安装g++sudo apt install g++  让我来写第一个代码并将其编译看看是否已经下载完毕： Hello.c: 12345#include &lt;stdio.h&gt;int main()&#123;    printf(&quot;Hello World&quot;);    return 0;&#125;  编译.c文件成可执行文件： gcc -o hello hello.c   执行这个可执行文件：   因为我们的Ubuntu系统是64位的系统，所以他也默认给我们生成了64位的文件。 我们可以下载如下库这样就支持我们编译成32位的文件了 12sudo apt install gcc-multilibsudo apt install...</div></div></div></a><a class="pagination-related" href="/posts/be4abe2b.html" title="02-x86_64架构汇编语言"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-26</div><div class="info-item-2">02-x86_64架构汇编语言</div></div><div class="info-2"><div class="info-item-1">x86_64架构汇编语言汇编的概念与常用寄存器汇编语言（Assembly Language）是一种低级编程语言，直接与计算机硬件交互。它是机器语言的符号化表示，人类可以通过汇编语言编写程序，而计算机则通过汇编语言指令与硬件进行通信。汇编语言具有与特定计算机体系结构（如 x86、ARM 等）密切相关的语法和指令集。 主要特点：  低级语言：汇编语言离机器语言非常近，指令与机器代码几乎一一对应。 面向硬件：汇编语言能精确控制计算机硬件资源，如寄存器、内存、I&#x2F;O...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/mbc.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">icon</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">21</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Iconabc"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Iconabc/" target="_blank" title="Github"><i class="fab fa-github" style="color: #hdhfbb;"></i></a><a class="social-icon" href="mailto:2899345299@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #000000;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">up up</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-C-%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E6%8A%80%E6%9C%AF"><span class="toc-number">1.</span> <span class="toc-text">C&#x2F;C++软件逆向技术</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E5%AE%9A%E4%BD%8D%E7%9B%AE%E6%A0%87%E5%8A%9F%E8%83%BD%EF%BC%9A"><span class="toc-number">1.1.</span> <span class="toc-text">分析定位目标功能：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9A%E9%80%9A%E8%BF%87%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9D%A5%E6%89%BE"><span class="toc-number">1.1.1.</span> <span class="toc-text">第一种方式：通过字符串来找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9A%E6%A0%B9%E6%8D%AE%E4%B8%80%E5%AE%9A%E8%A7%84%E5%88%99%E6%9D%A5%E7%A1%AE%E5%AE%9A"><span class="toc-number">1.1.2.</span> <span class="toc-text">第二种方式：根据一定规则来确定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9A%E5%AF%BC%E5%85%A5%E8%A1%A8%E6%9F%A5%E7%9C%8B"><span class="toc-number">1.1.3.</span> <span class="toc-text">第三种方式：导入表查看</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E8%B0%83%E8%AF%95%E6%9F%A5%E8%AF%A2%E6%BC%94%E7%A4%BA%EF%BC%9A"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">静态调试查询演示：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E6%BC%94%E7%A4%BA%EF%BC%9A"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">动态调试演示：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95%E6%89%BE%E5%88%B0%E6%8C%87%E5%AE%9A%E5%8A%9F%E8%83%BD%EF%BC%9A"><span class="toc-number">1.1.4.</span> <span class="toc-text">利用方法找到指定功能：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%9E%90%EF%BC%9A"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">分析：</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/cc605c90.html" title="03-C/C++软件逆向技术">03-C/C++软件逆向技术</a><time datetime="2024-12-28T05:19:21.000Z" title="发表于 2024-12-28 13:19:21">2024-12-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/be4abe2b.html" title="02-x86_64架构汇编语言">02-x86_64架构汇编语言</a><time datetime="2024-12-26T08:44:51.000Z" title="发表于 2024-12-26 16:44:51">2024-12-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/e11d0610.html" title="01-C++基础学习">01-C++基础学习</a><time datetime="2024-12-22T01:59:42.000Z" title="发表于 2024-12-22 09:59:42">2024-12-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/ad068c24.html" title="多级代理工具">多级代理工具</a><time datetime="2024-12-18T12:33:28.000Z" title="发表于 2024-12-18 20:33:28">2024-12-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/868e8d19.html" title="网络通信知识点小总">网络通信知识点小总</a><time datetime="2024-12-17T07:23:58.000Z" title="发表于 2024-12-17 15:23:58">2024-12-17</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/shuai.jpg);"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By icon</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><a href="/">icon</a> is striving to become stronger!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo

  const disqusReset = conf => {
    window.DISQUS && window.DISQUS.reset({
      reload: true,
      config: conf
    })
  }

  const loadDisqus = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyDisqus = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    window.disqus_identifier = isShuoshuo ? path : '/posts/cc605c90.html'
    window.disqus_url = isShuoshuo ? location.origin + path : 'https://iconabc.github.io/posts/cc605c90.html'

    const disqus_config = function () {
      this.page.url = disqus_url
      this.page.identifier = disqus_identifier
      this.page.title = '03-C/C++软件逆向技术'
    }

    if (window.DISQUS) disqusReset(disqus_config)
    else {
      const script = document.createElement('script')
      script.src = 'https://.disqus.com/embed.js'
      script.setAttribute('data-timestamp', +new Date())
      document.head.appendChild(script)
    }

    btf.addGlobalFn('themeChange', () => disqusReset(disqus_config), 'disqus')
  }

  const getCount = async() => {
    try {
      const eleGroup = document.querySelector('#post-meta .disqus-comment-count')
      if (!eleGroup) return
      const cleanedLinks = eleGroup.href.replace(/#post-comment$/, '')

      const res = await fetch(`https://disqus.com/api/3.0/threads/set.json?forum=&api_key=&thread:link=${cleanedLinks}`,{
        method: 'GET'
      })
      const result = await res.json()

      const count = result.response.length ? result.response[0].posts : 0
      eleGroup.textContent = count
    } catch (err) {
      console.error(err)
    }
  }

  if (isShuoshuo) {
    'Disqus' === 'Disqus'
      ? window.shuoshuoComment = { loadComment: loadDisqus }
      : window.loadOtherComment = loadDisqus
    return
  }

  if ('Disqus' === 'Disqus' || !false) {
    if (false) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
    else {
      loadDisqus()
      
    }
  } else {
    window.loadOtherComment = loadDisqus
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>